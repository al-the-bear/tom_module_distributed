/**
 * TypeScript implementation of Operation and Call classes.
 * 
 * Provides the same high-level API as the Dart RemoteLedgerClient with:
 * - Operation lifecycle management (create, join, leave, complete)
 * - Call tracking with typed results
 * - SpawnedCall for async operations with cancellation
 * - Client-side heartbeat management
 * - Abort/failure event handling
 */

// ═══════════════════════════════════════════════════════════════════
// TYPES AND ENUMS
// ═══════════════════════════════════════════════════════════════════

/**
 * Log levels for operation logging.
 */
export type LogLevel = 'debug' | 'info' | 'warning' | 'error';

/**
 * Heartbeat error types.
 */
export type HeartbeatErrorType = 
  | 'ledgerNotFound'
  | 'abortFlagSet'
  | 'heartbeatStale'
  | 'ioError';

/**
 * Heartbeat error details.
 */
export interface HeartbeatError {
  type: HeartbeatErrorType;
  message: string;
  cause?: unknown;
}

/**
 * Heartbeat result from server.
 */
export interface HeartbeatResult {
  abortFlag: boolean;
  ledgerExists: boolean;
  heartbeatUpdated: boolean;
  callFrameCount: number;
  tempResourceCount: number;
  heartbeatAgeMs: number;
  isStale: boolean;
  participants: string[];
  staleParticipants: string[];
}

/**
 * Information about an operation failure.
 */
export interface OperationFailedInfo {
  operationId: string;
  failedAt: Date;
  reason?: string;
  crashedCallIds: string[];
}

/**
 * Result from syncing multiple spawned calls.
 */
export interface SyncResult<T> {
  successfulCalls: SpawnedCall<T>[];
  failedCalls: SpawnedCall<T>[];
  unknownCalls: SpawnedCall<T>[];
  operationFailed: boolean;
}

// ═══════════════════════════════════════════════════════════════════
// CALLBACKS
// ═══════════════════════════════════════════════════════════════════

/**
 * Callback for operation-level events.
 */
export interface OperationCallback {
  onHeartbeatSuccess?: (operation: Operation, result: HeartbeatResult) => void;
  onHeartbeatError?: (operation: Operation, error: HeartbeatError) => void;
  onAbort?: (operation: Operation) => void;
  onFailure?: (operation: Operation, info: OperationFailedInfo) => void;
}

/**
 * Callback for call-level events.
 */
export interface CallCallback<T> {
  onCleanup?: () => Promise<void>;
  onCompletion?: (result: T) => Promise<void>;
  onCallCrashed?: () => Promise<T | null>;
  onOperationFailed?: (info: OperationFailedInfo) => Promise<void>;
}

/**
 * Heartbeat callback types.
 */
export type HeartbeatSuccessCallback = (operation: Operation, result: HeartbeatResult) => void;
export type HeartbeatErrorCallback = (operation: Operation, error: HeartbeatError) => void;

// ═══════════════════════════════════════════════════════════════════
// EXCEPTIONS
// ═══════════════════════════════════════════════════════════════════

/**
 * Exception thrown when an operation fails.
 */
export class OperationFailedException extends Error {
  readonly info: OperationFailedInfo;
  
  constructor(info: OperationFailedInfo) {
    super(info.reason ?? `Operation failed: ${info.operationId}`);
    this.name = 'OperationFailedException';
    this.info = info;
  }
}

// ═══════════════════════════════════════════════════════════════════
// CALL CLASS
// ═══════════════════════════════════════════════════════════════════

/**
 * Interface for operations that can manage call lifecycle.
 */
export interface CallLifecycle {
  endCallInternal<T>(callId: string, result?: T): Promise<void>;
  failCallInternal(callId: string, error: unknown, stackTrace?: string): Promise<void>;
}

/**
 * Represents an active call that was started synchronously.
 * 
 * This class is returned by Operation.startCall and provides methods
 * to end or fail the call without needing to track callIds manually.
 * 
 * @example
 * ```typescript
 * const call = await operation.startCall<number>();
 * try {
 *   const result = await computeSomething();
 *   await call.end(result);
 * } catch (e) {
 *   await call.fail(e);
 * }
 * ```
 */
export class Call<T> {
  /** The call ID generated by the ledger. */
  readonly callId: string;
  
  /** Optional description of this call. */
  readonly description?: string;
  
  /** When the call was started. */
  readonly startedAt: Date;
  
  /** The operation this call belongs to. */
  private readonly _operation: CallLifecycle;
  
  /** Whether this call has been ended or failed. */
  private _isCompleted = false;
  
  constructor(options: {
    callId: string;
    operation: CallLifecycle;
    startedAt: Date;
    description?: string;
  }) {
    this.callId = options.callId;
    this._operation = options.operation;
    this.startedAt = options.startedAt;
    this.description = options.description;
  }
  
  /** Whether this call has been ended or failed. */
  get isCompleted(): boolean {
    return this._isCompleted;
  }
  
  /**
   * End the call successfully with an optional result.
   */
  async end(result?: T): Promise<void> {
    if (this._isCompleted) {
      throw new Error(`Call ${this.callId} has already been completed`);
    }
    this._isCompleted = true;
    await this._operation.endCallInternal<T>(this.callId, result);
  }
  
  /**
   * Fail the call with an error.
   */
  async fail(error: unknown, stackTrace?: string): Promise<void> {
    if (this._isCompleted) {
      throw new Error(`Call ${this.callId} has already been completed`);
    }
    this._isCompleted = true;
    await this._operation.failCallInternal(this.callId, error, stackTrace);
  }
  
  toString(): string {
    return `Call(callId: ${this.callId}, completed: ${this._isCompleted})`;
  }
}

// ═══════════════════════════════════════════════════════════════════
// SPAWNED CALL CLASS
// ═══════════════════════════════════════════════════════════════════

/**
 * Represents a call that was spawned asynchronously.
 * 
 * This class tracks the state and result of a spawned call, and provides
 * control methods to cancel the call.
 * 
 * @example
 * ```typescript
 * const call = operation.spawnCall({
 *   work: async (call, op) => {
 *     // Check for cancellation periodically
 *     if (call.isCancelled) return null;
 *     return await doWork();
 *   },
 * });
 * 
 * // Wait for result
 * const result = await call.await();
 * ```
 */
export class SpawnedCall<T> {
  /** The call ID generated by the ledger. */
  readonly callId: string;
  
  /** Optional description of this call. */
  readonly description?: string;
  
  /** Internal promise for waiting on this call. */
  private _promise: Promise<void>;
  private _resolve!: () => void;
  private _reject!: (error: unknown) => void;
  
  /** Whether the call succeeded. */
  private _isSuccess = false;
  
  /** Whether cancellation has been requested. */
  private _isCancelled = false;
  
  /** The result of the call. */
  private _result?: T;
  
  /** The error if the call failed. */
  private _error?: unknown;
  
  /** The stack trace if the call failed. */
  private _stackTrace?: string;
  
  /** Whether completed. */
  private _isCompleted = false;
  
  /** Callback to be invoked when cancel() is called. */
  private _onCancel?: () => Promise<void>;
  
  constructor(options: { callId: string; description?: string }) {
    this.callId = options.callId;
    this.description = options.description;
    
    this._promise = new Promise<void>((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  
  /** Whether the call has completed (successfully or failed). */
  get isCompleted(): boolean {
    return this._isCompleted;
  }
  
  /** Whether the call completed successfully (not crashed). */
  get isSuccess(): boolean {
    return this._isSuccess;
  }
  
  /** Whether the call failed/crashed. */
  get isFailed(): boolean {
    return !this._isSuccess && this._isCompleted;
  }
  
  /** Whether cancellation has been requested. */
  get isCancelled(): boolean {
    return this._isCancelled;
  }
  
  /**
   * The result of the call (only valid if isSuccess is true).
   * @throws Error if accessed before completion or if call failed.
   */
  get result(): T {
    if (!this._isCompleted) throw new Error('Call not yet completed');
    if (!this._isSuccess) throw new Error('Call failed, no result available');
    return this._result as T;
  }
  
  /** The result if successful, undefined otherwise. */
  get resultOrNull(): T | undefined {
    return this._isSuccess ? this._result : undefined;
  }
  
  /**
   * The result if successful, or the provided default value.
   */
  resultOr(defaultValue: T): T {
    return this._isSuccess ? (this._result ?? defaultValue) : defaultValue;
  }
  
  /** Wait for this call to complete. */
  get future(): Promise<void> {
    return this._promise;
  }
  
  /** The error if the call failed. */
  get error(): unknown {
    return this._error;
  }
  
  /** The stack trace if the call failed. */
  get stackTrace(): string | undefined {
    return this._stackTrace;
  }
  
  /**
   * Request cancellation of this call.
   * 
   * This sets isCancelled to true and invokes the cancellation callback
   * if one was registered.
   */
  async cancel(): Promise<void> {
    if (this._isCancelled || this._isCompleted) return;
    this._isCancelled = true;
    await this._onCancel?.();
  }
  
  /**
   * Wait for the call to complete and return the result.
   * @throws Error if the call failed.
   */
  async await(): Promise<T> {
    await this._promise;
    return this.result;
  }
  
  /**
   * Complete this call successfully with the given result.
   * @internal
   */
  complete(result: T): void {
    if (this._isCompleted) return;
    this._result = result;
    this._isSuccess = true;
    this._isCompleted = true;
    this._resolve();
  }
  
  /**
   * Fail this call with the given error.
   * @internal
   */
  fail(error: unknown, stackTrace?: string): void {
    if (this._isCompleted) return;
    this._error = error;
    this._stackTrace = stackTrace;
    this._isSuccess = false;
    this._isCompleted = true;
    this._resolve(); // Still resolve - failure is checked via isSuccess
  }
  
  /**
   * Set the cancellation callback.
   * @internal
   */
  setOnCancel(onCancel: () => Promise<void>): void {
    this._onCancel = onCancel;
  }
  
  toString(): string {
    return `SpawnedCall(callId: ${this.callId}, completed: ${this._isCompleted}, success: ${this._isSuccess})`;
  }
}

// ═══════════════════════════════════════════════════════════════════
// OPERATION CLASS
// ═══════════════════════════════════════════════════════════════════

/**
 * Internal class representing a remote operation's state.
 * @internal
 */
export class OperationState {
  readonly operationId: string;
  readonly participantId: string;
  readonly pid: number;
  readonly isInitiator: boolean;
  readonly startTime: Date;
  
  heartbeatTimer?: ReturnType<typeof setInterval>;
  isAborted = false;
  joinCount = 0;
  sessionCounter = 0;
  
  readonly activeSessions = new Set<number>();
  readonly activeCalls = new Map<string, ActiveCallInfo<unknown>>();
  readonly calls = new Map<string, Call<unknown> | SpawnedCall<unknown>>();
  readonly sessionCalls = new Map<number, Set<string>>();
  
  private _abortResolve?: () => void;
  private _failureResolve?: (info: OperationFailedInfo) => void;
  
  readonly onAbortPromise: Promise<void>;
  readonly onFailurePromise: Promise<OperationFailedInfo>;
  
  constructor(options: {
    operationId: string;
    participantId: string;
    pid: number;
    isInitiator: boolean;
    startTime: Date;
  }) {
    this.operationId = options.operationId;
    this.participantId = options.participantId;
    this.pid = options.pid;
    this.isInitiator = options.isInitiator;
    this.startTime = options.startTime;
    
    this.onAbortPromise = new Promise<void>((resolve) => {
      this._abortResolve = resolve;
    });
    
    this.onFailurePromise = new Promise<OperationFailedInfo>((resolve) => {
      this._failureResolve = resolve;
    });
  }
  
  registerSession(sessionId: number): void {
    this.activeSessions.add(sessionId);
    this.sessionCalls.set(sessionId, new Set<string>());
    this.joinCount++;
    if (sessionId > this.sessionCounter) {
      this.sessionCounter = sessionId;
    }
  }
  
  stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = undefined;
    }
  }
  
  triggerAbort(): void {
    this.isAborted = true;
    this.stopHeartbeat();
    this._abortResolve?.();
  }
  
  signalFailure(info: OperationFailedInfo): void {
    this._failureResolve?.(info);
  }
  
  hasPendingCallsForSession(sessionId: number): boolean {
    return (this.sessionCalls.get(sessionId)?.size ?? 0) > 0;
  }
  
  pendingCallCountForSession(sessionId: number): number {
    return this.sessionCalls.get(sessionId)?.size ?? 0;
  }
}

/**
 * Active call tracking info.
 * @internal
 */
export interface ActiveCallInfo<T> {
  callId: string;
  sessionId: number;
  startedAt: Date;
  callback: CallCallback<T>;
  failOnCrash: boolean;
}

/**
 * Options for starting a call.
 */
export interface StartCallOptions<T> {
  description?: string;
  failOnCrash?: boolean;
  callback?: CallCallback<T>;
}

/**
 * Options for spawning a call.
 */
export interface SpawnCallOptions<T> {
  work: (call: SpawnedCall<T>, operation: Operation) => Promise<T>;
  description?: string;
  failOnCrash?: boolean;
  callback?: CallCallback<T>;
}

// Forward declaration - actual LedgerClient type
export interface LedgerClientInterface {
  post(path: string, body: Record<string, unknown>): Promise<{ status: number; body: string; ok: boolean }>;
  unregisterOperation(operationId: string): void;
}

/**
 * A remote operation handle with session tracking.
 * 
 * This provides the same interface as the Dart Operation but communicates
 * with a remote server for ledger access. Callbacks and work execution
 * happen client-side.
 * 
 * @example
 * ```typescript
 * const operation = await client.createOperation({
 *   description: 'Process payment',
 * });
 * 
 * const call = await operation.startCall<number>();
 * try {
 *   const result = await processPayment();
 *   await call.end(result);
 * } catch (e) {
 *   await call.fail(e);
 * }
 * 
 * await operation.complete();
 * ```
 */
export class Operation implements CallLifecycle {
  private readonly _state: OperationState;
  private readonly _client: LedgerClientInterface;
  
  /** The session ID for this operation handle. */
  readonly sessionId: number;
  
  constructor(
    state: OperationState,
    client: LedgerClientInterface,
    sessionId: number,
  ) {
    this._state = state;
    this._client = client;
    this.sessionId = sessionId;
  }
  
  // ─────────────────────────────────────────────────────────────
  // Properties
  // ─────────────────────────────────────────────────────────────
  
  get operationId(): string {
    return this._state.operationId;
  }
  
  get participantId(): string {
    return this._state.participantId;
  }
  
  get pid(): number {
    return this._state.pid;
  }
  
  get isInitiator(): boolean {
    return this._state.isInitiator;
  }
  
  get startTime(): Date {
    return this._state.startTime;
  }
  
  get isAborted(): boolean {
    return this._state.isAborted;
  }
  
  /** Future that completes when operation is aborted. */
  get onAbort(): Promise<void> {
    return this._state.onAbortPromise;
  }
  
  /** Future that completes when operation fails. */
  get onFailure(): Promise<OperationFailedInfo> {
    return this._state.onFailurePromise;
  }
  
  /** Elapsed time formatted as "SSS.mmm". */
  get elapsedFormatted(): string {
    const duration = Date.now() - this._state.startTime.getTime();
    const seconds = Math.floor(duration / 1000);
    const millis = duration % 1000;
    return `${seconds.toString().padStart(3, '0')}.${millis.toString().padStart(3, '0')}`;
  }
  
  /** Elapsed duration since operation start in ms. */
  get elapsedDuration(): number {
    return Date.now() - this._state.startTime.getTime();
  }
  
  /** Start time as ISO 8601 string. */
  get startTimeIso(): string {
    return this._state.startTime.toISOString();
  }
  
  /** Number of pending calls for this session. */
  get pendingCallCount(): number {
    return this._state.pendingCallCountForSession(this.sessionId);
  }
  
  // ─────────────────────────────────────────────────────────────
  // Call Management
  // ─────────────────────────────────────────────────────────────
  
  /**
   * Start a call tracked to this session.
   * 
   * Returns a Call<T> object for lifecycle management.
   */
  async startCall<T>(options: StartCallOptions<T> = {}): Promise<Call<T>> {
    const { description, failOnCrash = true, callback } = options;
    
    const response = await this._client.post('/call/start', {
      operationId: this.operationId,
      sessionId: this.sessionId,
      description,
      failOnCrash,
    });
    
    if (!response.ok) {
      throw new Error(`Failed to start call: ${response.body}`);
    }
    
    const data = JSON.parse(response.body);
    const callId = data.callId as string;
    const startedAt = new Date(data.startedAt as string);
    
    // Track call client-side
    const activeCall: ActiveCallInfo<T> = {
      callId,
      sessionId: this.sessionId,
      startedAt,
      callback: callback ?? {},
      failOnCrash,
    };
    this._state.activeCalls.set(callId, activeCall as ActiveCallInfo<unknown>);
    this._state.sessionCalls.get(this.sessionId)?.add(callId);
    
    // Create Call object
    const call = new Call<T>({
      callId,
      operation: this,
      startedAt,
      description,
    });
    this._state.calls.set(callId, call as Call<unknown>);
    
    return call;
  }
  
  /**
   * Spawn a call that runs asynchronously.
   * 
   * Work executes client-side; call frame is registered on server.
   * Returns immediately with a SpawnedCall<T>.
   */
  spawnCall<T>(options: SpawnCallOptions<T>): SpawnedCall<T> {
    const { work, description, failOnCrash = true, callback } = options;
    
    // Generate a temporary call ID
    const tempCallId = `spawn_${Date.now()}_${this._state.calls.size}`;
    
    // Create spawned call object immediately
    const spawnedCall = new SpawnedCall<T>({
      callId: tempCallId,
      description,
    });
    
    // Track in session
    this._state.sessionCalls.get(this.sessionId)?.add(tempCallId);
    this._state.calls.set(tempCallId, spawnedCall as SpawnedCall<unknown>);
    
    // Start the work asynchronously
    this._runSpawnedCall({
      spawnedCall,
      work: () => work(spawnedCall, this),
      callback: callback ?? {},
      description,
      failOnCrash,
    });
    
    return spawnedCall;
  }
  
  private async _runSpawnedCall<T>(options: {
    spawnedCall: SpawnedCall<T>;
    work: () => Promise<T>;
    callback: CallCallback<T>;
    description?: string;
    failOnCrash: boolean;
  }): Promise<void> {
    const { spawnedCall, work, callback, description, failOnCrash } = options;
    let serverCallId: string | undefined;
    
    try {
      // Register call frame on server
      const response = await this._client.post('/call/start', {
        operationId: this.operationId,
        sessionId: this.sessionId,
        description,
        failOnCrash,
      });
      
      if (!response.ok) {
        throw new Error(`Failed to start call: ${response.body}`);
      }
      
      const data = JSON.parse(response.body);
      serverCallId = data.callId as string;
      const startedAt = new Date(data.startedAt as string);
      
      // Track call client-side
      const activeCall: ActiveCallInfo<T> = {
        callId: serverCallId,
        sessionId: this.sessionId,
        startedAt,
        callback,
        failOnCrash,
      };
      this._state.activeCalls.set(serverCallId, activeCall as ActiveCallInfo<unknown>);
      
      // Execute the work
      const result = await work();
      
      // End call on server
      await this._client.post('/call/end', {
        operationId: this.operationId,
        callId: serverCallId,
      });
      
      // Remove from tracking
      this._state.activeCalls.delete(serverCallId);
      this._state.sessionCalls.get(this.sessionId)?.delete(spawnedCall.callId);
      this._state.calls.delete(spawnedCall.callId);
      
      // Trigger onCompletion callback
      await callback.onCompletion?.(result);
      
      // Complete the spawned call
      spawnedCall.complete(result);
    } catch (e) {
      // Handle failure
      if (serverCallId) {
        try {
          await this._client.post('/call/fail', {
            operationId: this.operationId,
            callId: serverCallId,
            error: String(e),
          });
        } catch {
          // Ignore server errors during failure handling
        }
        this._state.activeCalls.delete(serverCallId);
      }
      
      // Remove from tracking
      this._state.sessionCalls.get(this.sessionId)?.delete(spawnedCall.callId);
      this._state.calls.delete(spawnedCall.callId);
      
      // Try onCallCrashed callback for fallback
      let fallback: T | null = null;
      let hasFallback = false;
      if (callback.onCallCrashed) {
        try {
          fallback = await callback.onCallCrashed();
          hasFallback = fallback !== null;
        } catch {
          // Fallback failed
        }
      }
      
      // Trigger onCleanup callback
      await callback.onCleanup?.();
      
      if (hasFallback && fallback !== null) {
        spawnedCall.complete(fallback);
      } else {
        const stackTrace = e instanceof Error ? e.stack : undefined;
        spawnedCall.fail(e, stackTrace);
        
        // Signal operation failure if failOnCrash
        if (failOnCrash) {
          this._state.signalFailure({
            operationId: this.operationId,
            failedAt: new Date(),
            reason: `Spawned call failed: ${e}`,
            crashedCallIds: [serverCallId ?? spawnedCall.callId],
          });
        }
      }
    }
  }
  
  /** @internal */
  async endCallInternal<T>(callId: string, result?: T): Promise<void> {
    const activeCall = this._state.activeCalls.get(callId);
    if (!activeCall) {
      throw new Error(`No active call with ID: ${callId}`);
    }
    
    this._state.activeCalls.delete(callId);
    this._state.calls.delete(callId);
    this._state.sessionCalls.get(this.sessionId)?.delete(callId);
    
    // End call on server
    await this._client.post('/call/end', {
      operationId: this.operationId,
      callId,
    });
    
    // Trigger onCompletion callback client-side
    if (result !== undefined) {
      const typedCallback = activeCall.callback as CallCallback<T>;
      await typedCallback.onCompletion?.(result);
    }
  }
  
  /** @internal */
  async failCallInternal(callId: string, error: unknown, stackTrace?: string): Promise<void> {
    const activeCall = this._state.activeCalls.get(callId);
    if (!activeCall) {
      throw new Error(`No active call with ID: ${callId}`);
    }
    
    this._state.activeCalls.delete(callId);
    this._state.calls.delete(callId);
    this._state.sessionCalls.get(this.sessionId)?.delete(callId);
    
    // Fail call on server
    await this._client.post('/call/fail', {
      operationId: this.operationId,
      callId,
      error: String(error),
    });
    
    // Trigger onCleanup callback client-side
    await activeCall.callback.onCleanup?.();
    
    // Signal operation failure if failOnCrash
    if (activeCall.failOnCrash) {
      this._state.signalFailure({
        operationId: this.operationId,
        failedAt: new Date(),
        reason: `Call ${callId} failed: ${error}`,
        crashedCallIds: [callId],
      });
    }
  }
  
  // ─────────────────────────────────────────────────────────────
  // Session Call Tracking
  // ─────────────────────────────────────────────────────────────
  
  /** Check if this session has any pending calls. */
  hasPendingCalls(): boolean {
    return this._state.hasPendingCallsForSession(this.sessionId);
  }
  
  /** Get pending spawned calls for this session. */
  getPendingSpawnedCalls<T>(): SpawnedCall<T>[] {
    const callIds = this._state.sessionCalls.get(this.sessionId) ?? new Set<string>();
    const result: SpawnedCall<T>[] = [];
    for (const id of callIds) {
      const call = this._state.calls.get(id);
      if (call instanceof SpawnedCall && !call.isCompleted) {
        result.push(call as SpawnedCall<T>);
      }
    }
    return result;
  }
  
  /** Get pending regular calls for this session. */
  getPendingCalls<T>(): Call<T>[] {
    const callIds = this._state.sessionCalls.get(this.sessionId) ?? new Set<string>();
    const result: Call<T>[] = [];
    for (const id of callIds) {
      const call = this._state.calls.get(id);
      if (call instanceof Call && !call.isCompleted) {
        result.push(call as Call<T>);
      }
    }
    return result;
  }
  
  // ─────────────────────────────────────────────────────────────
  // Sync Methods
  // ─────────────────────────────────────────────────────────────
  
  /**
   * Wait for spawned calls to complete.
   */
  async sync<T>(
    calls: SpawnedCall<T>[],
    options: {
      onOperationFailed?: (info: OperationFailedInfo) => Promise<void>;
      onCompletion?: () => Promise<void>;
    } = {},
  ): Promise<SyncResult<T>> {
    const { onOperationFailed, onCompletion } = options;
    
    const successfulCalls: SpawnedCall<T>[] = [];
    const failedCalls: SpawnedCall<T>[] = [];
    const unknownCalls: SpawnedCall<T>[] = [];
    let operationFailed = false;
    
    // Wait for all calls or operation failure
    const callFutures = calls.map(c => c.future);
    const opFailureFuture = this.onFailure.then(async (info) => {
      operationFailed = true;
      await onOperationFailed?.(info);
    });
    
    await Promise.race([
      Promise.all(callFutures),
      opFailureFuture,
    ]);
    
    // Categorize calls
    for (const call of calls) {
      if (call.isCompleted) {
        if (call.isSuccess) {
          successfulCalls.push(call);
        } else {
          failedCalls.push(call);
        }
      } else {
        unknownCalls.push(call);
      }
    }
    
    // Trigger completion callback if all succeeded
    if (successfulCalls.length === calls.length && !operationFailed) {
      await onCompletion?.();
    }
    
    return {
      successfulCalls,
      failedCalls,
      unknownCalls,
      operationFailed,
    };
  }
  
  /**
   * Wait for a single spawned call to complete.
   */
  awaitCall<T>(
    call: SpawnedCall<T>,
    options: {
      onOperationFailed?: (info: OperationFailedInfo) => Promise<void>;
      onCompletion?: () => Promise<void>;
    } = {},
  ): Promise<SyncResult<T>> {
    return this.sync([call], options);
  }
  
  /**
   * Execute work while monitoring operation state.
   */
  async waitForCompletion<T>(
    work: () => Promise<T>,
    options: {
      onOperationFailed?: (info: OperationFailedInfo) => Promise<void>;
      onError?: (error: unknown) => Promise<T>;
    } = {},
  ): Promise<T> {
    const { onOperationFailed, onError } = options;
    
    // Race between work completion and operation failure
    const result = await Promise.race([
      work().then(r => ({ type: 'success' as const, result: r })),
      this.onFailure.then(info => ({ type: 'failed' as const, info })),
    ]);
    
    if (result.type === 'failed') {
      await onOperationFailed?.(result.info);
      throw new OperationFailedException(result.info);
    }
    
    return result.result;
  }
  
  // ─────────────────────────────────────────────────────────────
  // Operation Lifecycle
  // ─────────────────────────────────────────────────────────────
  
  /**
   * Leave this operation session.
   */
  async leave(options: { cancelPendingCalls?: boolean } = {}): Promise<void> {
    const { cancelPendingCalls = false } = options;
    
    // Check for pending calls
    const sessionCalls = this._state.sessionCalls.get(this.sessionId);
    if (sessionCalls && sessionCalls.size > 0 && !cancelPendingCalls) {
      throw new Error(
        `Session ${this.sessionId} has ${sessionCalls.size} pending calls. ` +
        'Use cancelPendingCalls: true to cancel them.',
      );
    }
    
    // Cancel pending calls if requested
    if (cancelPendingCalls && sessionCalls) {
      for (const callId of sessionCalls) {
        const call = this._state.calls.get(callId);
        if (call instanceof SpawnedCall) {
          await call.cancel();
        }
        this._state.activeCalls.delete(callId);
        this._state.calls.delete(callId);
      }
    }
    
    this._state.activeSessions.delete(this.sessionId);
    this._state.sessionCalls.delete(this.sessionId);
    this._state.joinCount--;
    
    // Notify server
    await this._client.post('/operation/leave', {
      operationId: this.operationId,
      sessionId: this.sessionId,
      cancelPendingCalls,
    });
    
    if (this._state.joinCount === 0) {
      this._state.stopHeartbeat();
      this._client.unregisterOperation(this.operationId);
    }
  }
  
  /**
   * Log a message to the operation.
   */
  async log(message: string, level: LogLevel = 'info'): Promise<void> {
    await this._client.post('/operation/log', {
      operationId: this.operationId,
      message,
      level,
    });
  }
  
  /**
   * Complete the operation.
   * Only the initiator can complete an operation.
   */
  async complete(): Promise<void> {
    if (!this.isInitiator) {
      throw new Error('Only the initiator can complete an operation');
    }
    this._state.stopHeartbeat();
    await this._client.post('/operation/complete', {
      operationId: this.operationId,
    });
    this._client.unregisterOperation(this.operationId);
  }
  
  /**
   * Set the abort flag for this operation.
   */
  async setAbortFlag(value: boolean = true): Promise<void> {
    await this._client.post('/operation/abort', {
      operationId: this.operationId,
      value,
    });
  }
  
  /**
   * Check if the operation has been aborted.
   */
  async checkAbort(): Promise<boolean> {
    const response = await this._client.post('/operation/state', {
      operationId: this.operationId,
    });
    const data = JSON.parse(response.body);
    const aborted = data.aborted as boolean ?? false;
    if (aborted && !this._state.isAborted) {
      this._state.triggerAbort();
    }
    return aborted;
  }
  
  /**
   * Trigger local abort.
   */
  triggerAbort(): void {
    this._state.triggerAbort();
  }
  
  // ─────────────────────────────────────────────────────────────
  // Heartbeat Management
  // ─────────────────────────────────────────────────────────────
  
  /**
   * Start the automatic heartbeat.
   */
  startHeartbeat(options: {
    intervalMs?: number;
    jitterMs?: number;
    onError?: HeartbeatErrorCallback;
    onSuccess?: HeartbeatSuccessCallback;
  } = {}): void {
    const {
      intervalMs = 4500,
      jitterMs = 500,
      onError,
      onSuccess,
    } = options;
    
    this._state.stopHeartbeat();
    this._scheduleNextHeartbeat({ intervalMs, jitterMs, onError, onSuccess });
  }
  
  private _scheduleNextHeartbeat(options: {
    intervalMs: number;
    jitterMs: number;
    onError?: HeartbeatErrorCallback;
    onSuccess?: HeartbeatSuccessCallback;
  }): void {
    if (this._state.isAborted) return;
    
    const { intervalMs, jitterMs, onError, onSuccess } = options;
    const jitter = Date.now() % jitterMs;
    const delay = intervalMs + jitter;
    
    this._state.heartbeatTimer = setTimeout(async () => {
      if (this._state.isAborted) return;
      await this._doHeartbeat({ onError, onSuccess });
      this._scheduleNextHeartbeat(options);
    }, delay);
  }
  
  private async _doHeartbeat(options: {
    onError?: HeartbeatErrorCallback;
    onSuccess?: HeartbeatSuccessCallback;
  }): Promise<void> {
    const { onError, onSuccess } = options;
    
    try {
      const response = await this._client.post('/operation/heartbeat', {
        operationId: this.operationId,
      });
      
      const data = JSON.parse(response.body);
      
      if (data.success !== true) {
        onError?.(this, {
          type: 'ledgerNotFound',
          message: data.reason ?? 'Unknown error',
        });
        return;
      }
      
      // Check for abort
      if (data.abortFlag === true) {
        this._state.triggerAbort();
        onError?.(this, {
          type: 'abortFlagSet',
          message: 'Abort flag is set',
        });
        return;
      }
      
      // Check for stale participants
      const staleParticipants = (data.staleParticipants as string[]) ?? [];
      if (staleParticipants.length > 0) {
        onError?.(this, {
          type: 'heartbeatStale',
          message: `Stale heartbeat detected from: ${staleParticipants.join(', ')}`,
        });
        return;
      }
      
      // Success
      onSuccess?.(this, {
        abortFlag: data.abortFlag ?? false,
        ledgerExists: true,
        heartbeatUpdated: true,
        callFrameCount: data.callFrameCount ?? 0,
        tempResourceCount: data.tempResourceCount ?? 0,
        heartbeatAgeMs: data.heartbeatAgeMs ?? 0,
        isStale: data.isStale ?? false,
        participants: data.participants ?? [],
        staleParticipants,
      });
    } catch (e) {
      onError?.(this, {
        type: 'ioError',
        message: `Heartbeat failed: ${e}`,
        cause: e,
      });
    }
  }
  
  /**
   * Stop the automatic heartbeat.
   */
  stopHeartbeat(): void {
    this._state.stopHeartbeat();
  }
  
  /**
   * Perform a single heartbeat and return the result.
   */
  async heartbeat(): Promise<HeartbeatResult | null> {
    try {
      const response = await this._client.post('/operation/heartbeat', {
        operationId: this.operationId,
      });
      
      const data = JSON.parse(response.body);
      
      if (data.success !== true) {
        return null;
      }
      
      return {
        abortFlag: data.abortFlag ?? false,
        ledgerExists: true,
        heartbeatUpdated: true,
        callFrameCount: data.callFrameCount ?? 0,
        tempResourceCount: data.tempResourceCount ?? 0,
        heartbeatAgeMs: data.heartbeatAgeMs ?? 0,
        isStale: data.isStale ?? false,
        participants: data.participants ?? [],
        staleParticipants: data.staleParticipants ?? [],
      };
    } catch {
      return null;
    }
  }
}
