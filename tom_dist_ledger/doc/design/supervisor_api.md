# Supervisor API Specification

## Overview

The Supervisor API enables external systems (like VS Code extensions, web servers, or orchestration services) to manage supervised calls in distributed operations. A supervisor is any system that spawns processes or manages resources on behalf of a call, and needs to be notified when that call fails.

---

## Core Concepts

### Supervisor
An external system that:
- Executes calls in its process, spawn new calls when they come in
- May manage other resource, for example the VS Code Supervisor can control most of VS Code
- Needs cleanup notifications when calls fail
- Maintains internal state about active calls (if needed)

### Supervised Call
A call that has a supervisor managing it:
- Created by `operation.startCallExecution()` 
- If call crashes, supervisor gets notified
- Supervisor is responsible for internal cleanup

### Supervisor Handle
An opaque identifier generated by the supervisor:
- Created by `supervisor.startCall()` when a call begins
- Used to identify which call crashed in notifications
- Passed to Supervisor as attribute of the `CallInfo` object it
- Supervisor handle can be any String e.g. current timestamp or random uuid.

### CallSupervisorCallback
Callbacks provided by the call to allow the supervisor to interact with it:
- `healthCheck()` - Query call health status
- `cleanup()` - Request the call to perform internal cleanup
- Passed to supervisor in `CallStartedInfo` and `CrashedCallInfo`

### CallLedgerCallback
Callbacks provided by the call for the ledger to manage cleanup:
- `cleanup()` - Called by ledger to cleanup call resources
- NOT passed to supervisor (internal ledger use only)

---

## Initialization

### Supervisor Implementation

First, create a Supervisor class that implements the required interface:

```dart
abstract class Supervisor {
  /// Unique identifier for this supervisor
  String get supervisorId;
  
  /// Called by ledger when a call starts. Returns supervisorHandle.
  String onCallStarted(CallStartedInfo info);
  
  /// Called by ledger when a call ends normally
  Future<void> onCallEnded(CallEndedInfo info);
  
  /// Called by ledger to perform supervisor-specific cleanup
  Future<void> onCallCleanup(CallCleanupInfo info);
  
  /// Called by ledger when a call crashes
  Future<void> onCallCrashed(CrashedCallInfo info);
}
```

### Single Ledger Initialization (Per Isolate)

```dart
import 'package:tom_dist_ledger/tom_dist_ledger.dart';

class MyCallSupervisor extends Supervisor {
  @override
  String get supervisorId => 'my-supervisor';
  
  @override
  String onCallStarted(CallStartedInfo info) {
    // Generate and return a supervisor handle for this call
    final handle = generateHandle();
    print('Call started: ${info.callId}');
    return handle;
  }
  
  @override
  Future<void> onCallEnded(CallEndedInfo info) async {
    print('Call ended: ${info.callId}');
    // Cleanup supervisor resources for this call
  }
  
  @override
  Future<void> onCallCleanup(CallCleanupInfo info) async {
    print('Performing cleanup for call: ${info.supervisorHandle}');
    // Perform supervisor-specific cleanup
  }
  
  @override
  Future<void> onCallCrashed(CrashedCallInfo info) async {
    print('Call crashed: ${info.callId}');
    // Handle crash notification
  }
}

void main() async {
  // Create supervisor instance
  final supervisor = MyCallSupervisor();
  
  // Initialize Ledger once per isolate with supervisor
  await Ledger.initSupervisorLedger(
    supervisor: supervisor,
    participantId: 'my-participant',
  );
  
  // Now Ledger is ready to be used
  final ledger = Ledger.instance;
  // ... rest of application
}
```

### Key Parameters

| Parameter | Type | Required | Purpose |
|-----------|------|----------|---------|
| `supervisor` | `Supervisor` | ✓ | Supervisor implementation for call management |
| `participantId` | `String` | ✓ | Unique identifier for this participant/isolate |

---

## Call Lifecycle

### Creating a Supervised Call

```dart
// Open or retrieve operation
final operation = await ledger.retrieveOperation(operationId: 'op_123');

// Start a supervised call
### Creating a Supervised Call

Calls create callbacks and pass them to `startCallExecution()`:

```dart
// Open or retrieve operation
final operation = await ledger.retrieveOperation(operationId: 'op_123');

// Create callbacks that the supervisor and ledger can call
final supervisorCallback = CallSupervisorCallback(
  healthCheck: () => _isHealthy(),
  cleanup: () => _performLocalCleanup(),
);

final ledgerCallback = CallLedgerCallback(
  cleanup: () => _releaseResources(),
);

// Start the call with callbacks
final supervisorHandle = await operation.startCallExecution(
  callId: 'call_456',
  supervisorCallback: supervisorCallback,
  ledgerCallback: ledgerCallback,
);

// The frame is now on the stack and supervisor.startCall() has been invoked
```

### Parameters Explained

```dart
await operation.startCallExecution({
  required String callId,                      // Unique in operation
  required CallSupervisorCallback supervisorCallback,  // Supervisor can call these
  required CallLedgerCallback ledgerCallback,   // Ledger calls these for cleanup
})
```

**Returns:** `supervisorHandle` generated by `supervisor.startCall()`

### Ending a Supervised Call (Normal)

```dart
// When call finishes successfully
await operation.endCall(
  callId: 'call_456',
);

// This:
// 1. Removes frame from stack (with stack-aware removal)
// 2. Triggers onCallEnded callback (if registered)
// 3. Continues cleanup sequence if operation is in cleanup state
```

---

## Callback Structures

### CallInfo (Base Class)

Base class for all call information passed to supervisor:

```dart
abstract class CallInfo {
  /// Unique call identifier
  final String callId;
  
  /// The operation this call belongs to
  final String operationId;
  
  /// Participant executing this call
  final String participantId;
  
  /// When this call started
  final DateTime startedAt;
  
  /// Callbacks the supervisor can invoke on this call
  final CallSupervisorCallback supervisorCallback;
}
```

### CallSupervisorCallback

Callbacks provided by the call for the supervisor to invoke:

```dart
class CallSupervisorCallback {
  /// Check if call is healthy
  Future<bool> Function() healthCheck;
  
  /// Request call to perform internal cleanup
  Future<void> Function() cleanup;
}
```

### CallLedgerCallback

Callbacks provided by the call for the ledger to invoke (NOT passed to supervisor):

```dart
class CallLedgerCallback {
  /// Called by ledger to cleanup call resources
  Future<void> Function() cleanup;
}
```

### CallStartedInfo

Passed to supervisor when a call starts.

```dart
class CallStartedInfo extends CallInfo {
  // Note: supervisorHandle is NOT set yet - supervisor generates it
}
```

**Example:**
```dart
// In supervisor.onCallStarted()
String onCallStarted(CallStartedInfo info) {
  final handle = generateHandle();
  log('Call ${info.callId} started at ${info.startedAt}');
  _trackCall(handle, info.supervisorCallback);
  return handle;
}
```

### CallEndedInfo

Passed to supervisor when a call ends normally.

```dart
class CallEndedInfo extends CallInfo {
  /// Supervisor's handle for this call
  final String supervisorHandle;
  
  /// When this call ended
  final DateTime endedAt;
  
  /// How long the call took
  Duration get duration => endedAt.difference(startedAt);
}
```

**Example:**
```dart
// In supervisor.onCallEnded()
Future<void> onCallEnded(CallEndedInfo info) async {
  final duration = info.duration.inMilliseconds;
  log('Call ${info.callId} completed in ${duration}ms');
  _recordMetrics(info.supervisorHandle, duration);
}
```

### CallCleanupInfo

Passed to supervisor when cleanup is needed for a call.

```dart
class CallCleanupInfo extends CallInfo {
  /// Supervisor's handle for this call
  final String supervisorHandle;
  
  /// The frame state at cleanup time
  final FrameState frameState;
  
  /// Whether this is during crash cleanup or normal cleanup
  final bool isCrashCleanup;
}
```

**Example:**
```dart
// In supervisor.onCallCleanup()
Future<void> onCallCleanup(CallCleanupInfo info) async {
  log('Cleaning up call: ${info.callId}');
  await _cleanupSupervisorResources(info.supervisorHandle);
}
```

### CrashedCallInfo

Passed to supervisor when a call crashes.

```dart
class CrashedCallInfo extends CallInfo {
  /// Supervisor's handle for this call
  final String supervisorHandle;
  
  /// When crash was detected
  final DateTime detectedAt;
  
  /// How long before crashing
  Duration get uptime => detectedAt.difference(startedAt);
  
  /// Details about the crash
  final String? crashReason;
  final StackTrace? stackTrace;
}
```

**Example:**
```dart
// In supervisor.onCallCrashed()
Future<void> onCallCrashed(CrashedCallInfo info) async {
  log('Call ${info.callId} crashed after ${info.uptime.inSeconds}s');
  await _cleanupResources(info.supervisorHandle);
  // Optional: report to monitoring
  await reportCrash(info);
}
```

---

## Supervisor Method Summary

| Method | Parameter | Returns | Purpose |
|--------|-----------|---------|---------|
| `onCallStarted` | `CallStartedInfo` | `String` (supervisorHandle) | Called when call starts, supervisor generates handle |
| `onCallEnded` | `CallEndedInfo` | `void` | Called when call ends normally |
| `onCallCleanup` | `CallCleanupInfo` | `void` | Called for supervisor-specific cleanup |
| `onCallCrashed` | `CrashedCallInfo` | `void` | Called when call crashes |

---

## Implementation Patterns

### Pattern 1: Simple Supervised Call

The call creates callbacks and passes them to `startCallExecution()`:

```dart
Future<void> executeCall(Operation operation) async {
  // Create supervisor callbacks
  final supervisorCallback = CallSupervisorCallback(
    healthCheck: () async => _isHealthy(),
    cleanup: () async => _performLocalCleanup(),
  );
  
  // Create ledger callbacks
  final ledgerCallback = CallLedgerCallback(
    cleanup: () async => _releaseResources(),
  );
  
  // Start the call with callbacks
  final supervisorHandle = await operation.startCallExecution(
    callId: 'call_456',
    supervisorCallback: supervisorCallback,
    ledgerCallback: ledgerCallback,
  );
  
  try {
    // Do the work
    await doWork();
    
    // End normally
    await operation.endCall(callId: 'call_456');
  } catch (e) {
    // On error, just don't call endCall
    // Ledger will detect stale heartbeat and notify supervisor
    rethrow;
  }
}
```

### Pattern 2: Supervisor Implementation

```dart
class MySupervisor extends Supervisor {
  
  @override
  String get supervisorId => "MyCompanyService";
  
  final _activeCalls = <String, CallMetadata>{};
  
  @override
  String onCallStarted(CallStartedInfo info) {
    // Generate handle for this call
    final handle = UUIDv4.uuid;
    _activeCalls[handle] = CallMetadata(info: info);
    print('Call started: ${info.callId}');
    return handle;
  }
  
  @override
  Future<void> onCallEnded(CallEndedInfo info) async {
    _activeCalls.remove(info.supervisorHandle);
    print('Call ended: ${info.callId} (duration: ${info.duration})');
  }
  
  @override
  Future<void> onCallCleanup(CallCleanupInfo info) async {
    print('Performing cleanup for: ${info.supervisorHandle}');
    // Cleanup supervisor-specific resources
    await _cleanupSupervisorResources(info.supervisorHandle);
  }
  
  @override
  Future<void> onCallCrashed(CrashedCallInfo info) async {
    final call = _activeCalls.remove(info.supervisorHandle);
    if (call != null) {
      print('Call crashed after ${info.uptime.inSeconds}s: ${info.callId}');
      await _handleCrash(info.supervisorHandle, info);
    }
  }
}

// During application startup
void main() async {
  final supervisor = MySupervisor();
  
  await Ledger.initSupervisorLedger(
    supervisor: supervisor,
    participantId: 'my-participant',
  );
  
  // Now ready to create calls
}
```

---

## Error Handling

### What If Supervisor Callback Throws?

The Ledger catches exceptions in callbacks and logs them, but **does not propagate**:

```dart
// In Ledger's cleanup:
try {
  await onCallCrashed(info).timeout(Duration(seconds:10));
} on Exception catch (e) {
  // Log the error
  print('Error in onCallCrashed callback: $e');
  
  // Continue cleanup anyway
  // Supervisor is responsible for handling exceptions
}
```

**Recommendation:** Supervisors should wrap callbacks in try-catch, use timeouts for await:

```dart
onCallCrashed: (info) async {
  try {
    await _cleanup(handle).timeout(Duration(seconds:10));
  } catch (e) {
    print('Cleanup failed for $handle: $e');
    // Log, report, or retry as needed
  }
},
```

### What If onCallCrashed Timeout?

There is  **no timeout** on the callback. If it hangs, Ledger will wait.

**Recommendation:** Use `Future.timeout()` if needed:

```dart
Ledger.initSupervisorLedger(
  supervisorId: 'bridge-supervisor',
  participantId: "bridge",
  onCallCrashed: (info) {
    return Future(
      () => _cleanup(handle),
    ).timeout(
      Duration(seconds: 30),
      onTimeout: () {
        print('Cleanup timeout for $handle');
        return null;
      },
    );
  },
);
```

### What If Supervisor Never Starts?

If `initSupervisorLedger()` is never called, supervised calls will not be supported:

- Calls still get supervisorHandle result, but it is of no significance.
- But no callbacks will be invoked on crash

---

## Heartbeat Continuation

When a supervisor detects that `operationState = cleanup`, it means a crash has been detected by a call heartbeat. The supervisor's heartbeat continues to run, allowing it to react and perform cleanup:

**Supervisor heartbeat during cleanup:**
1. Detect `operationState = cleanup` in their heartbeat
2. Scan the stack for crashed and cleanedUp frames with their supervisor ID
3. For each frame they manage:
   - Call `supervisor.performCleanupForCall(frame)` for internal cleanup
   - Mark frame as `dead`
   - Invoke `onCallCrashed` callback if registered
4. Wait one heartbeat, then do final cleanup pass for any remaining frames
5. Stop heartbeating

This gives supervised calls a self-cleanup window (Phase 2 of the cleanup sequence) before the coordinator removes remaining frames (Phase 3).

---

## Supervisor Domain

### What Is Supervised?

Only calls created with a `supervisorId` are supervised:

```dart
// Every call IS supervised if the ledger has been initialized correctly  
// Calls are not supervised if the ledger wasn't initialized explicitly
var supervisorHandle = await operation.startCallExecution(
  callId: 'call_1',
);

```

### Multiple Supervisors in One Operation

An operation cannot have multiple supervisors, because the ledger is tied to the supervisor.

### Call Hierarchy

Supervisors are not hierarchical - they are **parallel**, inside each of the participants, one per participant/isolate:

```
Operation
├─ Supervisor A
│  └─ Call A
├─ Supervisor B
│  └─ Call B
└─ Supervisor C
   └─ Call C
```

Each supervisor manages their own calls independently.

---

## Supervisor Heartbeat

### What Is Supervisor Heartbeat?

A supervisor heartbeat is an independent heartbeat for each supervisor:

```dart
{
  "supervisorId": "vscode-bridge",
  "status": "alive",
  "lastHeartbeat": "2026-01-21T10:30:00Z",
  "activeCalls": ["call_1", "call_2"],
  "crashes": []
}
```

### When Is Supervisor Dead?

A supervisor is considered dead when its heartbeat becomes stale:

```
Current time: T+60
Last heartbeat: T+40
Stale threshold: 20 seconds
Duration: 60 - 40 = 20 seconds

→ Supervisor is dead (last heartbeat too old)
```

### What Happens When Supervisor Dies?

If a supervisor's heartbeat becomes stale (detected during a call heartbeat), the supervisor is considered dead:

1. **Detection:** A call detects the supervisor's stale heartbeat
2. **Supervised frames marked:** All frames supervised by that dead supervisor are marked as `crashed`
3. **Self-cleanup window:** The supervisor gets one heartbeat window to react if it recovers
4. **Coordinator cleanup:** If supervisor doesn't recover, the coordinator removes all its frames in Phase 3
5. **No supervisor callbacks:** Since supervisor is dead, `onCallCrashed` callbacks cannot be invoked

This ensures that even if a supervisor dies, its supervised calls are still properly cleaned up by the distributed cleanup mechanism.

---

## Operation State Machine From Supervisor Perspective

From a supervisor's perspective, the operation state machine has these phases:

**Phase 1: Running** (`operationState = running`)
- Normal operation, all participants heartbeating
- Supervisor's `onCallStarted` and `onCallEnded` callbacks fire normally
- No cleanup activity

**Phase 2: Cleanup Detected** (`operationState = cleanup`)
- A crash has been detected by a call heartbeat
- Supervisor's heartbeat detects this and can invoke cleanup callbacks
- Supervisor calls `performCleanupForCall(frame)` for each supervised crashed/cleanedUp frame
- Supervisor invokes `onCallCrashed` callback for proper error handling
- Supervisor marks frames as `dead` when done
- Supervisor stops heartbeating after one heartbeat or when cleanup is complete

**Phase 3: Failed** (`operationState = failed`)
- Coordinator has removed all frames from stack
- All participants should have stopped heartbeating
- Operation is in terminal failure state

**Phase 4: File Deletion**
- Coordinator deletes the operation file
- Supervisor no longer receives any callbacks

---

## API Reference

### Ledger.initSupervisorLedger()

Initialize Ledger with a supervisor instance.

```dart
static Future<void> initSupervisorLedger({
  required Supervisor supervisor,
  required String participantId,
})
```

**When to call:** Once per isolate, before creating any calls.

**Thread safety:** Safe to call from any isolate. Uses isolate-local singleton.

**Example:**
```dart
final supervisor = MyCallSupervisor();
await Ledger.initSupervisorLedger(
  supervisor: supervisor,
  participantId: 'my-participant',
);
final ledger = Ledger.instance;
```

---

### operation.startCallExecution()

Create a supervised call and invoke supervisor.startCall().

```dart
Future<String> startCallExecution({
  required String callId,
  required CallSupervisorCallback supervisorCallback,
  required CallLedgerCallback ledgerCallback,
})
```

**Parameters:**
- `callId`: Unique identifier for this call
- `supervisorCallback`: Callbacks the supervisor can invoke on this call
- `ledgerCallback`: Callbacks the ledger uses for cleanup

**Returns:** `supervisorHandle` generated by `supervisor.startCall(CallStartedInfo)`

**Throws:** 
- `OperationNotFoundException` if operation doesn't exist
- `OperationFailedException` if operation is terminal

**Flow:**
1. Creates `CallStartedInfo` with call details and supervisor callback
2. Invokes `supervisor.startCall(callStartedInfo)`
3. Supervisor generates and returns `supervisorHandle`
4. Ledger stores both callbacks associated with this call
5. Returns supervisorHandle to caller

---

### operation.endCall()

End a supervised call normally.

```dart
Future<void> endCall({
  required String callId
})
```

**Parameters:**
- `callId`: Call to end

**Returns:** Future completes when frame is removed.

**Throws:**
- `OperationNotFoundException` if operation doesn't exist
- `CallNotFoundException` if call not in stack

**Flow:**
1. Creates `CallEndedInfo` with call duration and supervisor callback
2. Invokes `supervisor.endCall(supervisorHandle, callEndedInfo)`
3. Removes frame from stack

---

### operation.stateChanges

Stream of operation state changes.  
  
**USER: what states can we possibly receive here?**

```dart
Stream<OperationState> get stateChanges
```

**Example:**
```dart
operation.stateChanges.listen((state) {
  print('Operation state: $state');
});
```

---

### operation.waitForCleanup()

Get callback if cleanup is happening for doing call-internal cleanup

```dart
Future<void> registerForCleanup( CleanupCallback callback )
```

---


## Best Practices

1. **Initialize once**: Call `initSupervisorLedger()` exactly once per isolate
2. **Handle all callbacks**: Implement all three callbacks even if unused
3. **Use proper handles**: Make supervisor handles meaningful and stable
4. **Catch callback exceptions**: Don't let callback throw unhandled
5. **Log everything**: Log all callback invocations for debugging
6. **Test cleanup**: Test what happens when calls crash
7. **Monitor state**: Use state stream to detect failures
8. **Set timeouts**: Add timeouts to cleanup operations
9. **Document handles**: Document what each handle type represents
10. **Clean up resources**: Ensure all resources are released in callbacks
