# Distributed Ledger Specification

Complete specification for the distributed operations ledger system used to coordinate long-running operations across multiple participants.

---

## Table of Contents

1. [Overview](#overview)
2. [Terminology](#terminology)
3. [Architecture](#architecture)
4. [API Design](#api-design)
5. [Call Lifecycle](#call-lifecycle)
6. [Spawned Calls](#spawned-calls)
7. [Data Structures](#data-structures)
8. [Execution Helper Methods](#execution-helper-methods)
9. [Operation Logging](#operation-logging)
10. [Backup and Cleanup](#backup-and-cleanup)
11. [Cleanup Mechanism](#cleanup-mechanism)
12. [API Usage Examples](#api-usage-examples)
13. [Implementation Reference](#implementation-reference)

---

## Overview

The distributed ledger provides crash-resilient coordination for long-running operations that span multiple participants (processes). It uses file-based state management with heartbeat monitoring and automatic cleanup.

### Key Features

- **Crash detection** via heartbeat monitoring
- **Automatic cleanup** when participants crash
- **File-based coordination** using JSON ledger files
- **Backup retention** with configurable limits
- **Call tracking** with typed results and callbacks
- **Process control** with cancel/kill support

### Design Principles

1. **Ledger-managed IDs** - Call IDs are generated by the ledger
2. **Callback-based notification** - Each call has its own cleanup/crash callbacks
3. **Single coordinator** - First to detect crash coordinates cleanup
4. **Fixed timing** - Predictable heartbeat intervals and cleanup windows
5. **Typed results** - Generic support for call results

---

## Terminology

| Term | Description |
|------|-------------|
| **Operation** | A coordinated activity spanning multiple participants |
| **Participant** | A process taking part in an operation |
| **Initiator** | The participant that creates an operation |
| **Call** | A tracked unit of work within an operation |
| **SpawnedCall** | An asynchronous call that runs in the background |
| **Ledger** | The file-based storage for operation state |
| **Call Frame** | A record of an active call in the ledger |
| **Heartbeat** | Periodic timestamp update to signal liveness |
| **Cleanup** | Process of handling crashed participants |

---

## Architecture

### Roles

| Role | Description |
|------|-------------|
| **Initiator** | Creates operation, coordinates completion |
| **Participant** | Joins existing operation, performs work |

Both roles use the same `Operation` API. The difference is in how they obtain the operation handle:
- Initiator calls `ledger.createOperation()`
- Participant calls `ledger.joinOperation(operationId: ...)`

### File Structure

```
{basePath}/
├── {operationId}.operation.json     # Operation ledger data
├── {operationId}.operation.log      # Human-readable log
├── {operationId}.operation.debug.log # Debug log
└── backup/
    └── {operationId}/
        ├── operation.json
        ├── operation.log
        └── operation.debug.log
```

### Operation ID Format

```
YYYYMMDDTHH:MM:SS.sss-{participantId}-{random}
```

Example: `20260122T14:30:45.123-cli-a1b2c3d4`

---

## HTTP/REST Architecture

### Remote Access Overview

The distributed ledger supports both local and remote access patterns:

| Access Pattern | Class | Use Case |
|---------------|-------|----------|
| **Local** | `Ledger` | Same machine, file-based storage |
| **Remote** | `RemoteLedgerClient` | Network access via HTTP server |

Both implement the same `LedgerBase` interface, allowing transparent switching between local and remote access.

### Unified API

The remote API is **identical** to the local API, with the only difference being initialization:

| Feature | Local (`Operation`) | Remote (`RemoteOperation`) |
|---------|---------------------|---------------------------|
| `startCall<T>()` | Returns `Call<T>` | Returns `Call<T>` |
| `spawnCall<T>()` | Returns `SpawnedCall<T>` | Returns `SpawnedCall<T>` |
| `CallCallback<T>` | Full support | Full support (client-side) |
| Session tracking | Full support | Full support |
| `sync()` | Full support | Full support |

**Key design decision**: The server only handles file operations (read/write ledger JSON files, register call frames, update heartbeats). All callbacks, work execution, and session tracking happen client-side. This means:

- Callbacks are invoked on the client, not from the server
- Work functions run in the client process
- Type safety is preserved end-to-end
- Server remains stateless

### Class Hierarchy

```
LedgerBase (abstract)
├── Ledger           # Local file-based ledger
└── RemoteLedgerClient  # HTTP client for remote access

OperationBase (abstract)
├── Operation        # Local operation handle
└── RemoteOperation  # Remote operation handle (same API as Operation)
```

### LedgerServer

The `LedgerServer` class provides HTTP access to the ledger:

```dart
final server = await LedgerServer.start(
  basePath: '/tmp/ledger',
  port: 19876,
  address: InternetAddress.anyIPv4,  // Optional, defaults to loopback
);
```

The server is stateless - each request reads/writes files directly. Remote clients send their `participantId` with each request.

### RemoteLedgerClient

Clients connect using `RemoteLedgerClient.connect()`:

```dart
// Auto-discover a server on the network
final client = await RemoteLedgerClient.connect(
  participantId: 'remote_worker',
);

// Or connect to a specific server
final client = await RemoteLedgerClient.connect(
  serverUrl: 'http://localhost:19876',
  participantId: 'remote_worker',
  heartbeatInterval: Duration(seconds: 5),
  staleThreshold: Duration(seconds: 15),
);
```

If auto-discovery is not needed, direct construction is also available:

```dart
final client = RemoteLedgerClient(
  serverUrl: 'http://localhost:19876',
  participantId: 'remote_worker',
);
```

### HTTP Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/status` | GET | Server status and discovery |
| `/health` | GET | Server health check |
| `/operation/create` | POST | Create new operation |
| `/operation/join` | POST | Join existing operation |
| `/operation/leave` | POST | Leave operation session |
| `/operation/complete` | POST | Complete operation (initiator) |
| `/operation/heartbeat` | POST | Send heartbeat |
| `/operation/abort` | POST | Set abort flag |
| `/operation/state` | POST | Get operation state |
| `/operation/log` | POST | Write to operation log |
| `/call/start` | POST | Start a call |
| `/call/end` | POST | End call successfully |
| `/call/fail` | POST | Fail call with error |

### Request/Response Format

All endpoints use JSON. Example request:

```json
POST /operation/create
{
  "participantId": "remote_worker",
  "participantPid": 12345,
  "description": "Remote processing task"
}
```

Example response:

```json
{
  "operationId": "20260122T14:30:45.123-remote_worker-a1b2c3d4",
  "participantId": "remote_worker",
  "isInitiator": true,
  "sessionId": 1,
  "startTime": "2026-01-22T14:30:45.123Z"
}
```

### Error Handling

Errors return appropriate HTTP status codes:

| Status | Meaning |
|--------|---------|
| 200 | Success |
| 400 | Bad request (missing parameters) |
| 404 | Operation not found |
| 500 | Server error |

Error response format:

```json
{
  "error": "Missing operationId"
}
```

### RemoteLedgerException

Client-side errors throw `RemoteLedgerException`:

```dart
try {
  final op = await client.joinOperation(operationId: 'invalid');
} on RemoteLedgerException catch (e) {
  print('Error: ${e.message} (status: ${e.statusCode})');
}
```

---

## API Design

### Ledger Class

The `Ledger` class is the main entry point:

```dart
final ledger = Ledger(
  basePath: '/path/to/ledger',
  participantId: 'my-service',        // Required participant ID
  participantPid: pid,                 // Optional, defaults to current PID
  callback: LedgerCallback(            // Optional grouped callbacks
    onBackupCreated: (path) => print('Backup: $path'),
    onLogLine: (line) => print('Log: $line'),
  ),
  maxBackups: 20,                      // How many backups to retain
);
```

### Creating and Joining Operations

```dart
// Initiator creates operation - heartbeat auto-starts
final operation = await ledger.createOperation(
  participantId: 'initiator',  // Optional override
  description: 'My operation',
);
// ... do work ...
await operation.complete();  // Stops heartbeat, archives files

// Participant joins existing operation - heartbeat auto-starts
final operation = await ledger.joinOperation(
  operationId: 'known-operation-id',
  participantId: 'worker-1',  // Optional override
);
// ... do work ...
operation.leave();  // Stops heartbeat when join count reaches 0
```

**Join Count:** A participant may join the same operation multiple times
when handling multiple calls. Each `joinOperation` increments the join count,
and each `leave` decrements it. Heartbeat stops when count reaches 0.

### Call<T> Pattern

The primary pattern for tracking calls uses the `Call<T>` object returned by `startCall`:

```dart
// Start a call - returns Call<T> object
final call = await operation.startCall<ResultType>(
  callback: CallCallback<ResultType>(
    onCleanup: () async => releaseResources(),
    onCompletion: (result) async => print('Got: $result'),
  ),
  description: 'Process document',
  failOnCrash: true,  // Default: crash fails entire operation
);

try {
  final result = await performWork();
  await call.end(result);  // End with result
} catch (e, st) {
  await call.fail(e, st);  // Fail with error
}
```

**Key points:**
- `startCall<T>` returns a `Call<T>` object
- Use `call.end([result])` to complete successfully
- Use `call.fail(error, [stackTrace])` on error
- No need to track callIds manually

---

## Call Lifecycle

### Synchronous Calls

For synchronous work that you control directly:

```dart
final call = await operation.startCall<int>(
  callback: CallCallback(
    onCleanup: () async => cleanup(),
  ),
);

try {
  final result = await doWork();
  await call.end(result);
} catch (e, st) {
  await call.fail(e, st);
}
```

### Spawned Calls

For asynchronous work that runs in parallel:

```dart
// Spawn returns immediately
final spawned = operation.spawnCall<int>(
  work: () async => await computeValue(),
);

// callId available immediately
print('Started: ${spawned.callId}');

// Wait later
await spawned.future;
print('Result: ${spawned.result}');
```

---

## Spawned Calls

### SpawnedCall<T> Class

Spawned calls provide:
- Immediate access to `callId`
- Typed results via `result` property
- Control methods: `cancel()`, `kill()`, `await_()`
- Status via `isCompleted`, `isSuccess`, `isFailed`, `isCancelled`

### Spawning with Work Function

```dart
final call = operation.spawnCall<int>(
  work: () async {
    // Do async work
    return 42;
  },
  callback: CallCallback(
    onCompletion: (result) async => print('Got: $result'),
    onCallCrashed: () async => -1,  // Fallback value
  ),
);
```

### Spawning with Call Access

Use `workWithCall` when you need access to the `SpawnedCall` during execution (e.g., for cancellation checks or process attachment):

```dart
final call = operation.spawnCall<int>(
  workWithCall: (c) async {
    for (var i = 0; i < 100; i++) {
      if (c.isCancelled) return -1;  // Check cancellation
      await processChunk(i);
    }
    return 100;
  },
);

// Later, request cancellation
await call.cancel();
```

### Control Methods

#### cancel()

Request cooperative cancellation:

```dart
await call.cancel();
// Sets isCancelled = true
// Invokes cancellation callback if set
```

Work should check `isCancelled` periodically and exit gracefully.

#### kill()

Forcefully terminate associated process:

```dart
call.kill();  // Sends SIGTERM
call.kill(ProcessSignal.sigkill);  // Sends SIGKILL
```

Only works if a process was attached via `workWithCall` or exec helpers.

#### await_()

Wait for completion and get typed result:

```dart
final result = await call.await_();  // Returns T
// Throws StateError if call failed
```

### Syncing Multiple Calls

```dart
final call1 = operation.spawnCall<int>(work: () async => 1);
final call2 = operation.spawnCall<String>(work: () async => 'two');
final call3 = operation.spawnCall<bool>(work: () async => true);

final result = await operation.sync(
  [call1, call2, call3],
  onOperationFailed: (info) async {
    print('Operation failed!');
  },
);

if (result.allSucceeded) {
  print('Results: ${call1.result}, ${call2.result}, ${call3.result}');
} else {
  print('Failed: ${result.failedCalls.length}');
  print('Unknown: ${result.unknownCalls.length}');
}
```

### SyncResult

The `sync()` method returns a `SyncResult`:

```dart
class SyncResult {
  List<SpawnedCall> successfulCalls;
  List<SpawnedCall> failedCalls;
  List<SpawnedCall> unknownCalls;  // Still running when operation failed
  bool operationFailed;
  
  bool get allSucceeded;
  bool get hasFailed;
  bool get allResolved;
}
```

---

## Data Structures

### Operation File Structure

```json
{
  "operationId": "20260122T12:00:00.000-cli-a1b2c3d4",
  "initiatorId": "cli",
  "startTime": "2026-01-22T12:00:00Z",
  "operationState": "running",
  "lastHeartbeat": "2026-01-22T12:00:00Z",
  "detectionTimestamp": null,
  "removalTimestamp": null,
  "aborted": false,
  "callFrames": [
    {
      "callId": "call_cli_1_a1b2",
      "participantId": "cli",
      "pid": 12345,
      "startTime": "2026-01-22T12:00:00Z",
      "lastHeartbeat": "2026-01-22T12:00:00Z",
      "state": "active",
      "failOnCrash": true,
      "description": "Main task",
      "resources": []
    }
  ],
  "tempResources": []
}
```

### CallFrame Fields

| Field | Type | Description |
|-------|------|-------------|
| `callId` | string | Unique call identifier |
| `participantId` | string | Owning participant |
| `pid` | int | Process ID |
| `startTime` | datetime | When call started |
| `lastHeartbeat` | datetime | Last heartbeat update |
| `state` | enum | `active`, `crashed`, `cleaningUp`, `cleanedUp` |
| `failOnCrash` | boolean | Whether crash fails operation |
| `description` | string? | Human-readable description |
| `resources` | string[] | Temporary resources to cleanup |

### Operation States

```dart
enum OperationState {
  running,    // Normal execution
  cleanup,    // Crash detected, cleanup in progress
  failed,     // Cleanup complete, operation failed
  completed,  // Successfully completed
}
```

### Frame States

```dart
enum FrameState {
  active,      // Executing normally
  crashed,     // Participant crashed
  cleaningUp,  // Marked as cleanup coordinator
  cleanedUp,   // Completed cleanup
}
```

### Callback Classes

The API provides three callback classes for different scopes:

| Class | Scope | Key Callbacks |
|-------|-------|---------------|
| `LedgerCallback` | Ledger-level | `onBackupCreated`, `onLogLine`, `onGlobalHeartbeatError` |
| `OperationCallback` | Operation-level | `onHeartbeatSuccess`, `onHeartbeatError`, `onAbort`, `onFailure` |
| `CallCallback<T>` | Call-level | `onCleanup`, `onCompletion`, `onCallCrashed`, `onOperationFailed` |

**LedgerCallback** - Passed to `Ledger()` constructor for ledger-wide events like backup creation and global heartbeat monitoring.

**OperationCallback** - Passed to `createOperation()` or `joinOperation()` for operation-level events. Includes heartbeat monitoring (`onHeartbeatSuccess`, `onHeartbeatError`) and lifecycle events (`onAbort`, `onFailure`).

**CallCallback<T>** - Passed to `startCall()` for call lifecycle events including cleanup, completion, and crash recovery.

**Callback vs Future pattern:** `OperationCallback.onAbort` and `OperationCallback.onFailure` are alternatives to the `Operation.onAbort` and `Operation.onFailure` futures. Use callbacks for event-driven style, futures for racing with other work.

---

## Execution Helper Methods

### execFileResultWorker

Spawns a process that writes its result to a file:

```dart
final worker = operation.execFileResultWorker<Map<String, dynamic>>(
  executable: 'dart',
  arguments: ['run', 'worker.dart', '--output', resultPath],
  resultFilePath: resultPath,
  deserializer: (content) => jsonDecode(content),
  onExit: (exitCode) => print('Worker exited: $exitCode'),
);

// callId available immediately
print('Started: ${worker.callId}');

// Wait for result
await worker.future;
print('Result: ${worker.result}');
```

The method:
1. Starts the process
2. Attaches it to the SpawnedCall for kill support
3. Polls for the result file
4. Parses and returns the result

### execStdioWorker

Spawns a process that outputs result to stdout:

```dart
final worker = operation.execStdioWorker<WorkerResult>(
  executable: 'dart',
  arguments: ['run', 'worker.dart'],
  deserializer: (stdout) => WorkerResult.fromJson(jsonDecode(stdout)),
  onExit: (exitCode) => print('Worker exited: $exitCode'),
);

final result = await worker.await_();
```

### execServerRequest

For HTTP requests as spawned calls:

```dart
final request = operation.execServerRequest<Response>(
  work: () async {
    return await http.get(Uri.parse('http://api.example.com/data'));
  },
);

await request.future;
if (request.isSuccess) {
  print('Response: ${request.result.body}');
}
```

---

## Operation Logging

### Log Files

Each operation has two log files:

| File | Purpose | Format |
|------|---------|--------|
| `*.operation.log` | Human-readable events | Timestamped lines |
| `*.operation.debug.log` | Debug output | Timestamped lines |

### Writing to Log

```dart
// Application logging
await operation.log('Processing started');
await operation.log('Error occurred', level: LogLevel.error);

// Formatted message with participant
await operation.logMessage(
  depth: 2,
  message: 'Spawned worker',
);
```

### Log Levels

```dart
enum LogLevel { debug, info, warning, error }
```

### Lifecycle Events

| Event | Description |
|-------|-------------|
| `OPERATION_CREATED` | New operation started |
| `PARTICIPANT_JOINED` | Participant joined |
| `CALL_STARTED` | Call started |
| `CALL_SPAWNED` | Spawned call started |
| `CALL_COMPLETED` | Spawned call succeeded |
| `CALL_ENDED` | Synchronous call ended |
| `CALL_FAILED` | Call failed |
| `CRASH_DETECTED` | Stale heartbeat detected |
| `CLEANUP_STARTED` | Coordinator began cleanup |
| `OPERATION_FAILED` | Operation ended due to crash |
| `OPERATION_COMPLETED` | Successful completion |

---

## Backup and Cleanup

### Backup Mechanism

When an operation ends (completed or failed), files are moved to backup:

```
{basePath}/backup/{operationId}/
├── operation.json
├── operation.log
└── operation.debug.log
```

### Backup Retention

The ledger automatically cleans old backups:

```dart
final ledger = Ledger(
  basePath: '/path/to/ledger',
  maxBackups: 20,  // Keep last 20 operations
);
```

When backup count exceeds `maxBackups`, oldest backups (by operation ID timestamp) are deleted.

---

## Cleanup Mechanism

### Timing Constants

| Constant | Value | Purpose |
|----------|-------|---------|
| Heartbeat interval | 4-5 seconds (with jitter) | Time between heartbeats |
| Staleness threshold | 10 seconds | Time before frame considered dead |
| Self-cleanup window | 2 heartbeats (~10s) | Time for participants to self-cleanup |
| File deletion delay | 2 heartbeats (~10s) | Time before moving to backup |

### Phase Overview

```
T+0:  Crash occurs (heartbeat stops)
T+10: Phase 1 - Detection (coordinator marks crash)
T+20: Phase 2 - Self-Cleanup (others cleanup themselves)
T+30: Phase 3 - Frame Removal (coordinator removes frames)
T+40: Phase 4 - Backup (move files to backup)
```

### Phase 1: Detection

First participant to detect a stale frame becomes coordinator:

1. Lock operation file
2. Mark crashed frames (`state = crashed`)
3. Check `failOnCrash` attribute
4. If any crashed frame has `failOnCrash = true`: full cleanup
5. Set operation state to `cleanup`
6. Mark own frame as `cleaningUp` (coordinator marker)
7. Record `detectionTimestamp`
8. Continue heartbeating

### Phase 2: Self-Cleanup

Other participants detect `operationState = cleanup`:

1. Call own cleanup callback
2. Delete temp resources
3. Set frame `state = cleanedUp`
4. Stop heartbeating

### Phase 3: Frame Removal

Coordinator waits for cleanup window, then:

1. Lock operation file
2. Cleanup remaining frames
3. Remove all call frames
4. Set `operationState = failed`
5. Record `removalTimestamp`

### Phase 4: Backup

Coordinator waits, then:

1. Move operation files to backup folder
2. Clean old backups beyond retention limit
3. Stop heartbeating

### Contained Crashes (failOnCrash = false)

When a call has `failOnCrash = false`, its crash is contained:

- Operation does NOT enter cleanup state
- Only the crashed call is cleaned up
- Other calls continue normally
- The `onCallCrashed` callback can provide a fallback value

---

## API Usage Examples

### Example 1: Simple Call with Call<T>

```dart
final ledger = Ledger(
  basePath: '/tmp/ledger',
  participantId: 'processor',
);

Future<ProcessResult> processDocument(String operationId, String docPath) async {
  final operation = await ledger.joinOperation(operationId: operationId);
  
  final call = await operation.startCall<ProcessResult>(
    callback: CallCallback(
      onCleanup: () async => await releaseResources(),
    ),
    description: 'Process $docPath',
  );
  
  try {
    await operation.log('Processing: $docPath');
    final result = await doProcessing(docPath);
    await call.end(result);
    return result;
  } catch (e, st) {
    await call.fail(e, st);
    rethrow;
  }
}
```

### Example 2: Parallel Workers

```dart
Future<List<WorkerResult>> runParallelWorkers(String operationId) async {
  final operation = await ledger.joinOperation(operationId: operationId);
  
  // Spawn workers - returns immediately
  final workers = [
    for (var i = 0; i < 3; i++)
      operation.execFileResultWorker<WorkerResult>(
        executable: 'dart',
        arguments: ['run', 'worker.dart', '--id', '$i'],
        resultFilePath: '/tmp/result_$i.json',
        deserializer: (c) => WorkerResult.fromJson(jsonDecode(c)),
        onExit: (code) => print('Worker $i exited: $code'),
      ),
  ];
  
  // Wait for all
  final result = await operation.sync(workers);
  
  if (result.allSucceeded) {
    return workers.map((w) => w.result).toList();
  } else {
    throw Exception('${result.failedCalls.length} workers failed');
  }
}
```

### Example 3: Initiator with Workers

```dart
Future<BuildResult> coordinateBuild(BuildConfig config) async {
  // Heartbeat is auto-started when operation is created
  final operation = await ledger.createOperation(
    description: 'Build ${config.projectName}',
  );
  
  final call = await operation.startCall<void>(
    callback: CallCallback(
      onCleanup: () async => cleanupBuildArtifacts(),
    ),
  );
  
  try {
    // Spawn build workers
    final workers = await spawnBuildWorkers(operation, config);
    
    // Wait with operation awareness
    final results = await operation.waitForCompletion<List<BuildOutput>>(
      () async => await collectResults(workers),
      onOperationFailed: (info) async {
        print('Build failed: ${info.reason}');
      },
    );
    
    await call.end();
    await operation.complete(); // Stops heartbeat and archives files
    
    return BuildResult(outputs: results);
  } catch (e, st) {
    await call.fail(e, st);
    rethrow;
  } finally {
    await ledger.dispose();
  }
}
```

### Example 4: Cancellable Long-Running Task

```dart
final task = operation.spawnCall<List<ProcessedItem>>(
  workWithCall: (call) async {
    final results = <ProcessedItem>[];
    
    for (final item in items) {
      // Check for cancellation
      if (call.isCancelled) {
        await operation.log('Task cancelled, returning partial results');
        return results;
      }
      
      results.add(await processItem(item));
    }
    
    return results;
  },
);

// Later, if user wants to cancel:
await task.cancel();
final partialResults = await task.await_();
```

### Example 5: Error Handling with Fallbacks

```dart
try {
  final result = await operation.waitForCompletion<int>(
    () async => await riskyOperation(),
    onOperationFailed: (info) async {
      await operation.log('Operation failed: ${info.reason}', level: LogLevel.error);
    },
    onError: (error, stackTrace) async {
      await operation.log('Error in work: $error', level: LogLevel.warning);
      return -1;  // Fallback value
    },
  );
  
  if (result == -1) {
    print('Used fallback value');
  } else {
    print('Got result: $result');
  }
} on OperationFailedException catch (e) {
  print('Operation failed before work completed');
  print('Crashed calls: ${e.info.crashedCallIds}');
}
```

---

## Implementation Reference

### HeartbeatResult with Before/After Data

The `heartbeat()` method returns detailed state:

```dart
class HeartbeatResult {
  bool abortFlag;
  bool ledgerExists;
  bool heartbeatUpdated;
  int callFrameCount;
  int tempResourceCount;
  int heartbeatAgeMs;
  bool isStale;
  List<String> participants;
  Map<String, int> participantHeartbeatAges;
  List<String> staleParticipants;
  bool hasStaleChildren;
  LedgerData? dataBefore;   // State before heartbeat update
  LedgerData? dataAfter;    // State after heartbeat update
}
```

### waitForCompletion with Typed Error Handling

```dart
Future<T> waitForCompletion<T>(
  Future<T> Function() work, {
  Future<void> Function(OperationFailedInfo)? onOperationFailed,
  Future<T> Function(Object error, StackTrace stackTrace)? onError,
})
```

- Races work against operation failure
- If operation fails, calls `onOperationFailed` and throws `OperationFailedException`
- If work throws and `onError` is provided, uses it for fallback value
- If work throws and no `onError`, rethrows original error

### CallCallback<T> Structure

```dart
class CallCallback<T> {
  Future<void> Function()? onCleanup;
  Future<void> Function(T result)? onCompletion;
  Future<T?> Function()? onCallCrashed;
  Future<void> Function(OperationFailedInfo)? onOperationFailed;
}
```

---

## Benefits

✅ **Simpler API** - `Call<T>` object with `end()`/`fail()` methods  
✅ **Ledger-managed IDs** - No need to generate or track callIds  
✅ **Typed results** - Generic `SpawnedCall<T>` with typed `result`  
✅ **Process control** - `cancel()` and `kill()` for spawned processes  
✅ **Error handling** - `waitForCompletion` with `onError` fallback  
✅ **Better debugging** - `HeartbeatResult` with before/after state  
✅ **Predictable timing** - Fixed heartbeat intervals and cleanup windows  
✅ **Persistent history** - Backups preserved with configurable retention  

---

*tom_dist_ledger v2.0 Specification*

