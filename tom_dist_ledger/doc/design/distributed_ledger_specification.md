# Distributed Operation Ledger Specification

## Overview

The Distributed Operation Ledger (DOL) provides coordination and cleanup mechanisms for distributed operations spanning multiple processes. It uses a filesystem-based shared state model where participants communicate through YAML files.

This document consolidates the complete API specification and cleanup mechanism design.

---

## Table of Contents

1. [Terminology](#terminology)
2. [Architecture](#architecture)
3. [Roles and Responsibilities](#roles-and-responsibilities)
4. [API Specification](#api-specification)
5. [Data Structures](#data-structures)
6. [Operation Logging](#operation-logging)
7. [Backup and Cleanup](#backup-and-cleanup)
8. [Cleanup Mechanism](#cleanup-mechanism)
9. [API Usage Examples](#api-usage-examples)
10. [Implementation Reference](#implementation-reference)

---

## Terminology

| Term | Definition |
|------|------------|
| **Operation** | A complete flow of work from start to finish, coordinated through a shared ledger file. |
| **Participant** | A process or isolate that can participate in operations. Has one Ledger instance. |
| **Call** | A unit of work with its own stack frame. Multiple calls can exist per participant. |
| **Frame** | A stack entry representing one call's state in the operation. |
| **Heartbeat** | Periodic update proving liveness. Single heartbeat per participant. |
| **Coordinator** | The first participant to detect a crash becomes coordinator for cleanup. |
| **Operation Log** | Append-only log file for recording operation events. |
| **Debug Log** | Detailed debug output file (separate from operation log). |

---

## Architecture

### Component Hierarchy

```
Participant (Process/Isolate)
├── Ledger (singleton, one per isolate)
└── Calls (multiple, each with its own frame)
    └── Frame (stack entry in operation file)
```

### Key Relationships

- **One Ledger per isolate** - Initialized once via `Ledger.initLedger()`
- **Multiple Calls per participant** - Each call has its own frame in the operation stack
- **Ledger-generated call IDs** - Call IDs are generated by the ledger, not the application

### File Location and Naming

**Active operations:**
```
_ai/ops_ledger/
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.yaml       # Operation state
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.log        # Operation log
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.debug.log  # Debug log
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.yaml.lock  # Lock file (transient)
└── ...
```

**Backup location:**
```
_ai/ops_ledger/backup/
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.yaml
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.log
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.debug.log
└── ...
```

**Operation ID Format:**
```
{timestamp}-{initiator-participant-id}-{short-random}
```

- **timestamp** - `YYYYMMDDTHH:MM:SS.sss` (ISO 8601 with milliseconds)
- **initiator-participant-id** - ID of the participant that started the operation
- **short-random** - First 8 characters of a UUID (e.g., `a1b2c3d4`)

**Example:** `20260121T14:30:45.123-vscode-bridge-a1b2c3d4`

---

## Roles and Responsibilities

### Ledger

The Ledger is the central coordination component:

- **Creates and manages operation files** - YAML-based shared state
- **Generates call IDs** - Unique identifiers for each call
- **Manages call frames** - Push/pop frames on operation stack
- **Runs heartbeats** - Single heartbeat loop per participant
- **Detects crashes** - Identifies stale frames via heartbeat staleness
- **Coordinates cleanup** - First detector becomes cleanup coordinator
- **Invokes callbacks** - Calls application cleanup callbacks during crash handling
- **Manages operation logs** - Writes to operation log file
- **Handles backup** - Moves completed/failed operations to backup folder
- **Cleans old backups** - Removes backups beyond configured retention limit

### Call

A Call represents a unit of work:

- **Executes application logic** - The actual work being done
- **Provides callbacks** - Cleanup and optional crash notification
- **Has a frame** - Entry in the operation stack tracking its state
- **Participates in heartbeat** - Updated via participant's heartbeat loop
- **Has ledger-generated ID** - Receives callId from ledger when started

---

## API Specification

### Ledger Initialization

```dart
static Future<void> initLedger({
  required String participantId,
  int maxBackups = 20,
})
```

Initializes the Ledger singleton.

**Parameters:**
- `participantId` - Unique identifier for this participant
- `maxBackups` - Maximum number of backup operations to retain (default: 20)

**Note:** Call exactly once per isolate before creating any calls.

---

### Operation API

#### Create Operation (Initiator Only)

```dart
Future<Operation> createOperation({
  String? description,
})
```

Creates a new operation. Only the initiator calls this.

**Returns:** Operation with generated operationId

**Actions:**
1. Generates operationId: `{timestamp}-{participantId}-{random}`
2. Creates operation YAML file
3. Creates empty operation log file
4. Creates empty debug log file

#### Join Operation (Non-Initiator)

```dart
Future<Operation> joinOperation({
  required String operationId,
})
```

Joins an existing operation created by another participant.

#### Start a Call

```dart
Future<String> startCall({
  required CallCallback callback,
  String? description,
})
```

**Parameters:**
- `callback` - Application callbacks for cleanup and crash notification
- `description` - Optional human-readable description of this call

**Returns:** `callId` generated by the ledger

**Actions:**
1. Generates unique callId
2. Creates frame with `state = active`
3. Starts heartbeat if first call for this participant
4. Logs "CALL_STARTED" to operation log
5. Returns callId

#### End a Call

```dart
Future<void> endCall({
  required String callId,
})
```

**Parameters:**
- `callId` - The call ID returned from `startCall()`

**Actions:**
1. Removes frame from stack
2. Logs "CALL_ENDED" to operation log
3. Calls `callback.onEnded()` if provided
4. If last call for this participant: stops heartbeat

#### Complete Operation (Initiator Only)

```dart
Future<void> completeOperation()
```

Marks the operation as successfully completed.

**Actions:**
1. Sets `operationState = completed`
2. Logs "OPERATION_COMPLETED" to operation log
3. Moves all operation files to backup folder
4. Cleans old backups beyond retention limit

#### Wait for Completion with Crash Awareness

```dart
Future<void> waitForCompletion(
  Future<void> Function() work, {
  Future<void> Function(OperationFailedInfo info)? onCrash,
})
```

Executes asynchronous work while monitoring operation state. If the operation enters cleanup/failed state, the work is interrupted.

**Parameters:**
- `work` - The async function to execute (e.g., waiting for workers)
- `onCrash` - Optional callback invoked when operation fails during wait

**Behavior:**
- Uses a `Completer` internally to race between work completion and operation failure
- If `operationState` becomes `cleanup` or `failed`, completes immediately
- If work completes normally, returns normally
- Does NOT use simple timeout - responds to actual operation state changes

**Example:**
```dart
await operation.waitForCompletion(
  () async => await _waitForWorkers(),
  onCrash: (info) async {
    print('Operation failed: ${info.reason}');
    await _cleanupPartialWork();
  },
);
```

#### Spawn Call (Parallel Execution)

```dart
Future<String> spawnCall({
  required CallCallback callback,
  String? description,
})
```

Starts a call that runs asynchronously without blocking. The call executes in parallel with other spawned calls.

**Parameters:**
- `callback` - Application callbacks for cleanup and crash notification
- `description` - Optional human-readable description

**Returns:** `callId` generated by the ledger (immediately, before call completes)

**Actions:**
1. Generates unique callId
2. Creates frame with `state = active`
3. Returns callId immediately (does not wait for call to complete)
4. The spawned call runs independently

**Note:** Unlike `startCall()`, the caller does not need to call `endCall()` - the spawned call manages its own lifecycle.

#### Sync on Spawned Calls

```dart
Future<void> sync(
  List<String> callIds, {
  Future<void> Function(String callId, CrashedCallInfo info)? onCrash,
  Future<void> Function(OperationFailedInfo info)? onOperationFailed,
})
```

Waits for all specified spawned calls to complete.

**Parameters:**
- `callIds` - List of call IDs returned from `spawnCall()`
- `onCrash` - Called for each individual call that crashes
- `onOperationFailed` - Called if the entire operation fails

**Behavior:**
- Waits until all specified calls have ended (normally or crashed)
- If a call crashes, invokes `onCrash` for that call but continues waiting for others
- If operation enters `failed` state, invokes `onOperationFailed` and returns immediately
- Returns when all calls have finished or operation has failed

**Example:**
```dart
final id1 = await operation.spawnCall(callback: callback1, description: 'Task 1');
final id2 = await operation.spawnCall(callback: callback2, description: 'Task 2');
final id3 = await operation.spawnCall(callback: callback3, description: 'Task 3');

await operation.sync(
  [id1, id2, id3],
  onCrash: (callId, info) async {
    print('Call $callId crashed: ${info.crashReason}');
  },
  onOperationFailed: (info) async {
    print('Operation failed, aborting sync');
  },
);
```

---

### Callback Structure

```dart
class CallCallback {
  /// Called by ledger during crash cleanup
  final Future<void> Function() cleanup;
  
  /// Optional: Called when call ends normally
  final Future<void> Function(CallEndedInfo info)? onEnded;
  
  /// Optional: Called when this call crashes (detected by another participant)
  final Future<void> Function(CrashedCallInfo info)? onCrashed;
  
  /// Optional: Health check for diagnostics
  final Future<bool> Function()? healthCheck;
}
```

**Note:** The `onCrashed` callback replaces the Supervisor's crash notification. Each call can have its own crash handler.

---

### CallInfo Classes

#### CallEndedInfo

Passed to `callback.onEnded()`:

```dart
class CallEndedInfo {
  final String callId;
  final String operationId;
  final String participantId;
  final DateTime startedAt;
  final DateTime endedAt;
  Duration get duration => endedAt.difference(startedAt);
}
```

#### CrashedCallInfo

Passed to `callback.onCrashed()`:

```dart
class CrashedCallInfo {
  final String callId;
  final String operationId;
  final String participantId;
  final DateTime startedAt;
  final DateTime detectedAt;
  Duration get uptime => detectedAt.difference(startedAt);
  final String? crashReason;
}
```

#### OperationFailedInfo

Passed to `onCrash` in `waitForCompletion()` and `onOperationFailed` in `sync()`:

```dart
class OperationFailedInfo {
  final String operationId;
  final DateTime failedAt;
  final String? reason;
  final List<String> crashedCallIds;
}
```

---

### Operation Logging API

```dart
/// Write an entry to the operation log
Future<void> log(String message, {LogLevel level = LogLevel.info});

/// Write an entry to the debug log (INTERNAL USE ONLY)
Future<void> debugLog(String message);
```

**Log levels:**
```dart
enum LogLevel { debug, info, warning, error }
```

The operation log is opened in append mode, allowing concurrent writes from multiple participants without conflicts.

**Note on debugLog:** The `debugLog()` method is for **internal ledger use only**, primarily for testing and debugging the ledger implementation itself. Application code (initiators and participants) should use `log()` instead. Debug logging may be disabled in production and should not be relied upon for application-level logging.

---

## Data Structures

### Operation File Structure

```yaml
operationId: "20260121T12:00:00.000-cli-a1b2c3d4"
operationState: running
initiatorId: cli
lastHeartbeat: "2026-01-21T12:00:00Z"
detectionTimestamp: null
removalTimestamp: null
stack:
  - callId: "call_001"
    participantId: cli
    state: active
    lastHeartbeat: "2026-01-21T12:00:00Z"
    description: "tom build --watch"
    resources: []
  - callId: "call_002"
    participantId: vscode-bridge
    state: active
    lastHeartbeat: "2026-01-21T12:00:00Z"
    description: "Execute script: process_doc.dart"
    resources:
      - "_ai/temp/req_123.json"
```

### Operation States

```dart
enum OperationState {
  /// Operation is running normally
  running,
  
  /// Crash detected, cleanup in progress
  cleanup,
  
  /// Cleanup complete, operation failed
  failed,
  
  /// Operation completed successfully
  completed,
}
```

### Frame States

```dart
enum FrameState {
  /// Frame is executing normally
  active,
  
  /// Frame's participant has crashed
  crashed,
  
  /// Frame marked as cleanup coordinator
  cleaningUp,
  
  /// Frame has completed cleanup
  cleanedUp,
}
```

---

## Operation Logging

### Log Files

Each operation has two log files:

| File | Purpose | Format |
|------|---------|--------|
| `*.operation.log` | Human-readable operation events | Timestamped lines |
| `*.operation.debug.log` | Detailed debug output | Timestamped lines |

### Log File Format

```
2026-01-21T12:00:00.123Z [INFO] CALL_STARTED callId=call_001 participant=cli
2026-01-21T12:00:05.456Z [INFO] CALL_STARTED callId=call_002 participant=vscode-bridge
2026-01-21T12:00:10.789Z [INFO] CALL_ENDED callId=call_001 duration=10.666s
2026-01-21T12:00:15.012Z [ERROR] CRASH_DETECTED callId=call_002 reason=stale_heartbeat
2026-01-21T12:00:15.123Z [INFO] CLEANUP_STARTED coordinator=cli
2026-01-21T12:00:20.456Z [INFO] OPERATION_FAILED
```

### Write Mode

Log files are opened in **append mode** to allow concurrent writes from multiple participants without locking conflicts.

### Lifecycle Events

| Event | Description |
|-------|-------------|
| `OPERATION_CREATED` | New operation started by initiator |
| `PARTICIPANT_JOINED` | Participant joined existing operation |
| `CALL_STARTED` | New call started |
| `CALL_ENDED` | Call ended normally |
| `CRASH_DETECTED` | Stale heartbeat detected |
| `CLEANUP_STARTED` | Coordinator began cleanup |
| `CALL_CRASHED` | Call marked as crashed |
| `OPERATION_FAILED` | Operation ended due to crash |
| `OPERATION_COMPLETED` | Operation completed successfully |

---

## Backup and Cleanup

### Backup Mechanism

When an operation ends (completed or failed), all operation files are moved to the backup folder:

```
_ai/ops_ledger/backup/
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.yaml
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.log
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.debug.log
└── ...
```

### Backup Cleanup

The ledger automatically cleans old backups during operation cleanup:

1. **Trigger:** After moving files to backup (Phase 4 of cleanup or normal completion)
2. **Action:** List all backup files, sorted by timestamp
3. **Retention:** Keep only the most recent `maxBackups` operations (default: 20)
4. **Deletion:** Remove all files for operations beyond the retention limit

```dart
// Configuration in Ledger.initLedger()
await Ledger.initLedger(
  participantId: 'my-service',
  maxBackups: 20,  // Keep last 20 operations
);
```

### Backup Cleanup Algorithm

```dart
Future<void> _cleanOldBackups() async {
  final backupDir = Directory('$ledgerPath/backup');
  if (!await backupDir.exists()) return;
  
  // Get unique operation IDs from backup files
  final files = await backupDir.list().toList();
  final operationIds = files
    .map((f) => _extractOperationId(f.path))
    .whereType<String>()
    .toSet()
    .toList();
  
  // Sort by timestamp (embedded in operation ID)
  operationIds.sort((a, b) => b.compareTo(a));  // Newest first
  
  // Delete operations beyond retention limit
  if (operationIds.length > _maxBackups) {
    final toDelete = operationIds.skip(_maxBackups);
    for (final opId in toDelete) {
      await _deleteOperationFiles(backupDir, opId);
    }
  }
}
```

---

## Cleanup Mechanism

### Design Principles

The cleanup mechanism is **sequential and coordinator-based**:

- **Single coordinator** - First to detect crash coordinates entire cleanup
- **Four phases** - Detection → Self-Cleanup → Frame Removal → Backup
- **Fixed timing** - Each phase separated by heartbeat intervals
- **Callback-based crash notification** - Each call has its own `onCrashed` callback

### Timing Constants

| Constant | Value | Purpose |
|----------|-------|---------|
| Heartbeat interval | 4-5 seconds (with jitter) | Time between heartbeats |
| Staleness threshold | 10 seconds | Time before frame considered dead |
| Self-cleanup window | 2 heartbeats (~10s) | Time for participants to self-cleanup |
| File deletion delay | 2 heartbeats (~10s) | Time before moving to backup |

### Phase Overview

```
T+0: Crash occurs (heartbeat stops)
T+2: Phase 1 - Detection (coordinator marks crash, signals cleanup)
T+3: Phase 2 - Self-Cleanup Window (others cleanup themselves)
T+4: Phase 3 - Frame Removal (coordinator removes remaining frames)
T+6: Phase 4 - Backup (coordinator moves files to backup, cleans old backups)
```

---

### Phase 1: Detection

**Trigger:** Call heartbeat detects stale frame (heartbeat > 10s old)

**First detector becomes coordinator:**

1. **Lock operation file**
2. **Mark crashed frames** → `state = crashed`
3. **Mark all other frames** → `state = cleanup` (signals them to self-cleanup)
4. **Set operation state** → `operationState = cleanup`
5. **Log** → "CRASH_DETECTED" and "CLEANUP_STARTED" to operation log
5. **Perform own cleanup:**
   - Call `callback.cleanup()` on own frame
   - Call `frame.cleanup()` (deletes temp resources)
   - Set own frame `state = cleaningUp` (marks as coordinator)
6. **Record timestamp** → `detectionTimestamp = now()`
7. **Release lock**
8. **Continue heartbeating** (coordinator role)

**Important:** Other participants are NOT yet notified. They will detect the state change in their next heartbeat.

---

### Phase 2: Self-Cleanup Window

**Trigger:** Participant heartbeat detects `operationState = cleanup`

**Non-coordinator calls:**

1. Detect `operationState = cleanup`
2. Call `callback.cleanup()` on own frame
3. Call `frame.cleanup()` (deletes temp resources)
4. Set own frame `state = cleanedUp`
5. Log "CALL_ENDED" (cleanup) to operation log
6. **Stop heartbeating**

**Crashed call notification (by coordinator):**

1. For each crashed frame, if `callback.onCrashed` is available:
   - Call `callback.onCrashed(CrashedCallInfo)`
2. Log "CALL_CRASHED" for each crashed call

---

### Phase 3: Frame Removal

**Trigger:** Coordinator detects `now() - detectionTimestamp >= 2 * heartbeatInterval`

**Coordinator actions:**

1. **Lock operation file**
2. **Cleanup remaining frames** (still in cleanup/crashed state)
   - Call `frame.cleanup()` on each
3. **Remove all frames** from stack
4. **Set operation state** → `operationState = failed`
5. **Log** → "OPERATION_FAILED" to operation log
6. **Record timestamp** → `removalTimestamp = now()`
7. **Release lock**

At this point, all other participants should have stopped heartbeating.

---

### Phase 4: Backup

**Trigger:** Coordinator detects `now() - removalTimestamp >= 2 * heartbeatInterval`

**Coordinator actions:**

1. **Move operation files** to backup folder
2. **Clean old backups** beyond retention limit
3. **Stop heartbeating**

The extra delay allows any remaining participants to detect the `failed` state before the files are moved.

---

## API Usage Examples

### Example 1: Simple Call Execution

```dart
// Application startup
await Ledger.initLedger(
  participantId: 'my-service',
  maxBackups: 20,
);

// Execute a call
Future<void> executeWork(String operationId) async {
  final ledger = Ledger.instance;
  final operation = await ledger.joinOperation(operationId: operationId);
  
  // Create callback for cleanup and crash notification
  final callback = CallCallback(
    cleanup: () async {
      // Release resources, close connections, etc.
      await _releaseResources();
    },
    onEnded: (info) async {
      print('Call completed in ${info.duration.inMilliseconds}ms');
    },
    onCrashed: (info) async {
      print('Call crashed after ${info.uptime.inSeconds}s');
      await _handleCrash();
    },
  );
  
  // Start the call - ledger generates callId
  final callId = await operation.startCall(
    callback: callback,
    description: 'Process document',
  );
  
  try {
    // Log progress
    await operation.log('Processing started');
    
    // Do the work
    await _processDocument();
    
    await operation.log('Processing completed');
    
    // End normally
    await operation.endCall(callId: callId);
  } catch (e) {
    // On crash, don't call endCall
    // Ledger will detect stale heartbeat and trigger cleanup
    rethrow;
  }
}
```

### Example 2: Initiator Creating Operation

```dart
// Initiator creates a new operation
Future<void> startDistributedTask() async {
  final ledger = Ledger.instance;
  
  // Create new operation
  final operation = await ledger.createOperation(
    description: 'Build project documentation',
  );
  
  print('Created operation: ${operation.operationId}');
  // Example: 20260121T14:30:45.123-cli-a1b2c3d4
  
  // Start initiator's own call
  final callId = await operation.startCall(
    callback: CallCallback(
      cleanup: () async => await _cleanup(),
    ),
    description: 'Coordinate build',
  );
  
  try {
    // Spawn other participants, passing operation.operationId
    await _spawnWorker(operation.operationId);
    
    // Wait for work to complete - with crash awareness
    // This does NOT use a simple timeout - it responds to operation state changes
    await operation.waitForCompletion(
      () async => await _waitForWorkers(),
      onCrash: (info) async {
        print('Operation crashed: ${info.reason}');
        // Cleanup is already being handled by the ledger
        // This callback is for application-level notification
      },
    );
    
    // End our call
    await operation.endCall(callId: callId);
    
    // Complete the operation (moves to backup)
    await operation.completeOperation();
  } catch (e) {
    // On error, cleanup will handle everything
    rethrow;
  }
}
```

### Example 3: Sequential Calls with Manual Lifecycle

```dart
// Start multiple calls sequentially - caller manages lifecycle
final operation = await ledger.joinOperation(operationId: 'op_123');

// Start calls - each gets its own callId
final callId1 = await operation.startCall(
  callback: callback1,
  description: 'Task 1',
);
// Do work for task 1...
await operation.endCall(callId: callId1);

final callId2 = await operation.startCall(
  callback: callback2,
  description: 'Task 2',
);
// Do work for task 2...
await operation.endCall(callId: callId2);
```

### Example 4: Parallel Calls with Spawn and Sync

```dart
// Spawn multiple calls that run in parallel
final operation = await ledger.joinOperation(operationId: 'op_123');

// Spawn calls - returns immediately with callId
// The calls run asynchronously in parallel
final id1 = await operation.spawnCall(
  callback: CallCallback(
    cleanup: () async => await _cleanup1(),
    onCrashed: (info) async => print('Task 1 crashed'),
  ),
  description: 'Task 1',
);
final id2 = await operation.spawnCall(
  callback: callback2,
  description: 'Task 2',
);
final id3 = await operation.spawnCall(
  callback: callback3,
  description: 'Task 3',
);

// All three calls are now running in parallel
// Sync on all of them - waits for all to complete
await operation.sync(
  [id1, id2, id3],
  onCrash: (callId, info) async {
    print('Call $callId crashed after ${info.uptime.inSeconds}s');
    // Handle individual call crash
  },
  onOperationFailed: (info) async {
    print('Entire operation failed');
    // All calls will be cleaned up by the ledger
  },
);

print('All spawned calls have completed');
```

### Example 5: Using Operation Log

```dart
final operation = await ledger.joinOperation(operationId: operationId);

// Log to operation log (visible in backup)
await operation.log('Starting document processing');
await operation.log('Processed 50 files', level: LogLevel.info);
await operation.log('Skipped invalid file: foo.txt', level: LogLevel.warning);

// Note: debugLog() is for INTERNAL ledger testing only
// Application code should use log() instead
```

---

## Implementation Reference

### Heartbeat Loop (Pseudo-code)

The single heartbeat loop handles crash detection and cleanup:

```dart
Future<void> _heartbeatLoop() async {
  while (_running) {
    await _performHeartbeat();
    
    // Random jitter: 4000-5000ms
    final delay = 4000 + _random.nextInt(1000);
    await Future.delayed(Duration(milliseconds: delay));
  }
}

Future<void> _performHeartbeat() async {
  final data = await operation.retrieveAndLockOperation();
  if (data == null) {
    _stopHeartbeat();
    return;
  }
  
  // Check for stale frames (crash detection)
  var foundCrash = false;
  for (var frame in data.stack) {
    if (frame.isStale(thresholdMs: stalenessThresholdMs)) {
      foundCrash = true;
      frame.state = FrameState.crashed;
    }
  }
  
  if (foundCrash && data.operationState == OperationState.running) {
    // First detector becomes coordinator
    await _becomeCoordinator(data);
    return;
  }
  
  // React to cleanup state if already in cleanup
  if (data.operationState == OperationState.cleanup) {
    await _handleCleanupState(data);
    return;
  }
  
  // Update heartbeat timestamp
  data.lastHeartbeat = DateTime.now();
  for (var frame in data.stack.where((f) => f.participantId == participantId)) {
    frame.lastHeartbeat = DateTime.now();
  }
  
  await operation.writeAndUnlockOperation(data);
}
```

### Coordinator Cleanup (Pseudo-code)

```dart
Future<void> _becomeCoordinator(OperationData data) async {
  // Log crash detection
  await operation.log('CRASH_DETECTED', level: LogLevel.error);
  await operation.log('CLEANUP_STARTED coordinator=$participantId');
  
  // Mark all non-crashed frames for cleanup
  for (var frame in data.stack) {
    if (frame.state == FrameState.active) {
      frame.state = FrameState.cleanup;
    }
  }
  
  // Perform own cleanup
  final myFrame = data.stack.firstWhere((f) => f.callId == _currentCallId);
  await _callbackMap[myFrame.callId]?.cleanup();
  await myFrame.cleanup();
  myFrame.state = FrameState.cleaningUp;  // Mark as coordinator
  
  // Set operation to cleanup state
  data.operationState = OperationState.cleanup;
  data.detectionTimestamp = DateTime.now();
  
  await operation.writeAndUnlockOperation(data);
  
  // Continue heartbeating for Phase 3 and 4
}
```

### Crash Notification (Pseudo-code)

```dart
Future<void> _notifyCrashedCalls(OperationData data) async {
  for (var frame in data.stack) {
    if (frame.state == FrameState.crashed) {
      final callback = _callbackMap[frame.callId];
      if (callback?.onCrashed != null) {
        final info = CrashedCallInfo(
          callId: frame.callId,
          operationId: data.operationId,
          participantId: frame.participantId,
          startedAt: frame.startedAt,
          detectedAt: data.detectionTimestamp!,
        );
        await callback!.onCrashed!(info);
      }
      await operation.log('CALL_CRASHED callId=${frame.callId}');
    }
  }
}
```

### Backup Handler (Pseudo-code)

```dart
Future<void> _performBackup(String operationId) async {
  final backupDir = Directory('$ledgerPath/backup');
  await backupDir.create(recursive: true);
  
  // Move all operation files to backup
  final files = [
    '$operationId.operation.yaml',
    '$operationId.operation.log',
    '$operationId.operation.debug.log',
  ];
  
  for (final filename in files) {
    final source = File('$ledgerPath/$filename');
    if (await source.exists()) {
      await source.rename('${backupDir.path}/$filename');
    }
  }
  
  // Clean old backups
  await _cleanOldBackups();
}
```

---

## Comparison: Previous vs Current Design

| Aspect | Previous | Current |
|--------|----------|---------|
| Supervisor | Separate abstract class | Removed - callbacks on call |
| Call ID generation | Application provides | Ledger generates |
| Supervisor handle | Returned by supervisor | Removed |
| Crash notification | Via supervisor | Via call callback |
| File format | JSON | YAML |
| Operation ID | `op_YYYYMMDD_HHMMSS_xxxx` | `YYYYMMDDTHH:MM:SS.sss-participant-xxxx` |
| File deletion | Delete after cleanup | Move to backup |
| Backup cleanup | Not specified | Configurable retention (default: 20) |
| Operation logging | Not specified | Append-mode log files |

---

## Benefits

✅ **Simpler API** - No Supervisor class, callbacks directly on calls  
✅ **Ledger-managed IDs** - No need to generate callIds  
✅ **Better traceability** - Operation ID contains timestamp and initiator  
✅ **Persistent history** - Backups preserved with configurable retention  
✅ **Operation logging** - Events recorded for debugging and auditing  
✅ **Predictable timing** - Fixed heartbeat intervals, known cleanup windows  
✅ **No race conditions** - File lock prevents concurrent modifications  
✅ **Testable** - Each phase is independently verifiable  

---

## Implementation Checklist

- [ ] Define `OperationState` and `FrameState` enums
- [ ] Implement `CallCallback` class with cleanup, onEnded, onCrashed
- [ ] Implement `CallEndedInfo`, `CrashedCallInfo`, and `OperationFailedInfo` classes
- [ ] Implement `Ledger.initLedger()` with maxBackups parameter
- [ ] Implement `createOperation()` with new ID format
- [ ] Implement `joinOperation()`
- [ ] Implement `startCall()` with ledger-generated callId
- [ ] Implement `endCall()`
- [ ] Implement `completeOperation()`
- [ ] Implement `waitForCompletion()` with Completer-based interruption
- [ ] Implement `spawnCall()` for parallel call execution
- [ ] Implement `sync()` for waiting on multiple spawned calls
- [ ] Implement `log()` method for operation logging
- [ ] Implement `debugLog()` method (internal use only)
- [ ] Implement unified heartbeat loop
- [ ] Implement Phase 1: Detection and coordinator selection
- [ ] Implement Phase 2: Self-cleanup with crash notification
- [ ] Implement Phase 3: Frame removal
- [ ] Implement Phase 4: Backup and old backup cleanup
- [ ] Write unit tests for each phase
- [ ] Write integration tests for multi-participant scenarios

