# Distributed Operation Ledger Specification

## Overview

The Distributed Operation Ledger (DOL) provides coordination and cleanup mechanisms for distributed operations spanning multiple processes. It uses a filesystem-based shared state model where participants communicate through JSON files.

This document consolidates the complete API specification and cleanup mechanism design.

---

## Table of Contents

1. [Terminology](#terminology)
2. [Architecture](#architecture)
3. [Roles and Responsibilities](#roles-and-responsibilities)
4. [API Specification](#api-specification)
5. [Data Structures](#data-structures)
6. [Operation Logging](#operation-logging)
7. [Backup and Cleanup](#backup-and-cleanup)
8. [Cleanup Mechanism](#cleanup-mechanism)
9. [API Usage Examples](#api-usage-examples)
10. [Implementation Reference](#implementation-reference)

---

## Terminology

| Term | Definition |
|------|------------|
| **Operation** | A complete flow of work from start to finish, coordinated through a shared ledger file. |
| **Participant** | A process or isolate that can participate in operations. Has one Ledger instance. |
| **Call** | A unit of work with its own stack frame. Multiple calls can exist per participant. |
| **Frame** | A stack entry representing one call's state in the operation. |
| **Heartbeat** | Periodic update proving liveness. Single heartbeat per participant. |
| **Coordinator** | The first participant to detect a crash becomes coordinator for cleanup. |
| **Operation Log** | Append-only log file for recording operation events. |
| **Debug Log** | Detailed debug output file (separate from operation log). |

---

## Architecture

### Component Hierarchy

```
Participant (Process/Isolate)
├── Ledger (singleton, one per isolate)
└── Calls (multiple, each with its own frame)
    └── Frame (stack entry in operation file)
```

### Key Relationships

- **One Ledger per isolate** - Initialized once via `Ledger.initLedger()`
- **Multiple Calls per participant** - Each call has its own frame in the operation stack
- **Ledger-generated call IDs** - Call IDs are generated by the ledger, not the application

### File Location and Naming

**Active operations:**
```
_ai/ops_ledger/
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.json       # Operation state
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.log        # Operation log
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.debug.log  # Debug log
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.json.lock  # Lock file (transient)
└── ...
```

**Backup location:**
```
_ai/ops_ledger/backup/
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.json
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.log
├── 20260121T12:00:00.000-cli-a1b2c3d4.operation.debug.log
└── ...
```

**Operation ID Format:**
```
{timestamp}-{initiator-participant-id}-{short-random}
```

- **timestamp** - `YYYYMMDDTHH:MM:SS.sss` (ISO 8601 with milliseconds)
- **initiator-participant-id** - ID of the participant that started the operation
- **short-random** - First 8 characters of a UUID (e.g., `a1b2c3d4`)

**Example:** `20260121T14:30:45.123-vscode-bridge-a1b2c3d4`

---

## Roles and Responsibilities

### Ledger

The Ledger is the central coordination component:

- **Creates and manages operation files** - JSON-based shared state
- **Generates call IDs** - Unique identifiers for each call
- **Manages call frames** - Push/pop frames on operation stack
- **Runs heartbeats** - Single heartbeat loop per participant
- **Detects crashes** - Identifies stale frames via heartbeat staleness
- **Coordinates cleanup** - First detector becomes cleanup coordinator
- **Invokes callbacks** - Calls application cleanup callbacks during crash handling
- **Manages operation logs** - Writes to operation log file
- **Handles backup** - Moves completed/failed operations to backup folder
- **Cleans old backups** - Removes backups beyond configured retention limit

### Call

A Call represents a unit of work:

- **Executes application logic** - The actual work being done
- **Provides callbacks** - Cleanup and optional crash notification
- **Has a frame** - Entry in the operation stack tracking its state
- **Participates in heartbeat** - Updated via participant's heartbeat loop
- **Has ledger-generated ID** - Receives callId from ledger when started

---

## API Specification

### Ledger Initialization

```dart
static Future<void> initLedger({
  required String participantId,
  int maxBackups = 20,
})
```

Initializes the Ledger singleton.

**Parameters:**
- `participantId` - Unique identifier for this participant
- `maxBackups` - Maximum number of backup operations to retain (default: 20)

**Note:** Call exactly once per isolate before creating any calls.

---

### Operation API

#### Create Operation (Initiator Only)

```dart
Future<Operation> createOperation({
  String? description,
})
```

Creates a new operation. Only the initiator calls this.

**Returns:** Operation with generated operationId

**Actions:**
1. Generates operationId: `{timestamp}-{participantId}-{random}`
2. Creates operation JSON file
3. Creates empty operation log file
4. Creates empty debug log file

#### Join Operation (Non-Initiator)

```dart
Future<Operation> joinOperation({
  required String operationId,
})
```

Joins an existing operation created by another participant.

#### Start a Call

```dart
Future<String> startCall({
  required CallCallback callback,
  String? description,
  bool failOnCrash = true,
})
```

**Parameters:**
- `callback` - Application callbacks for cleanup and crash notification
- `description` - Optional human-readable description of this call
- `failOnCrash` - Whether a crash in this call should fail the entire operation (default: `true`). If `false`, a crash in this call will be contained and will not trigger operation-wide cleanup; other calls can continue.

**Returns:** `callId` generated by the ledger

**Actions:**
1. Generates unique callId
2. Creates frame with `state = active` and `failOnCrash` flag
3. Starts heartbeat if first call for this participant
4. Logs "CALL_STARTED" to operation log
5. Returns callId

#### End a Call

```dart
Future<void> endCall({
  required String callId,
})
```

**Parameters:**
- `callId` - The call ID returned from `startCall()`

**Actions:**
1. Removes frame from stack
2. Logs "CALL_ENDED" to operation log
3. Calls `callback.onEnded()` if provided
4. If last call for this participant: stops heartbeat

#### Fail a Call (Explicit Failure)

```dart
Future<void> failCall({
  required String callId,
  Object? error,
  StackTrace? stackTrace,
})
```

Explicitly marks a call as failed. Use this when an exception occurs but the process has not crashed (heartbeat would continue indefinitely otherwise).

**Parameters:**
- `callId` - The call ID returned from `startCall()`
- `error` - Optional error object that caused the failure
- `stackTrace` - Optional stack trace

**Actions:**
1. Marks frame as `state = crashed`
2. Sets `operationState = cleanup` (triggers cleanup for other participants)
3. Logs "CALL_FAILED" with error details to operation log
4. Calls `callback.cleanup()` for this call
5. Calls `callback.onCrashed()` if provided
6. Removes frame from stack
7. If this was the only call for this participant: stops heartbeat

**When to use:**
- When a call throws an exception that should abort the operation
- When a call cannot continue but the process itself is still running
- When you want deterministic failure detection (not relying on heartbeat staleness)

**Important:** Relying on stale heartbeat detection only works if the process actually crashes. If an exception is caught and the process continues running, the heartbeat continues and the failure is never detected. Always use `failCall()` for explicit failure handling.

**Example:**
```dart
final callId = await operation.startCall(
  callback: callback,
  description: 'Process document',
);

try {
  await _processDocument();
  await operation.endCall(callId: callId);
} catch (e, st) {
  // IMPORTANT: Use failCall() instead of relying on stale heartbeat
  // Heartbeat continues if process doesn't crash - failure never detected!
  await operation.failCall(callId: callId, error: e, stackTrace: st);
  rethrow;
}
```

#### Complete Operation (Initiator Only)

```dart
Future<void> completeOperation()
```

Marks the operation as successfully completed.

**Actions:**
1. Sets `operationState = completed`
2. Logs "OPERATION_COMPLETED" to operation log
3. Moves all operation files to backup folder
4. Cleans old backups beyond retention limit

#### Wait for Completion with Crash Awareness

```dart
Future<T?> waitForCompletion<T>(
  Future<T> Function() work, {
  Future<T?> Function(OperationFailedInfo info)? onCrash,
})
```

Executes asynchronous work while monitoring operation state. If the operation enters cleanup/failed state, the work is interrupted and `onCrash` is invoked.

**Type Parameter:**
- `T` - The return type of the work function

**Parameters:**
- `work` - The async function to execute, returns `Future<T>` (e.g., waiting for workers and collecting results)
- `onCrash` - Optional callback invoked when operation fails during wait; can return a fallback value of type `T?`

**Returns:** 
- The result of `work()` if it completes successfully (type `T`)
- The result of `onCrash()` if operation fails during wait (type `T?`)
- `null` if operation fails and no `onCrash` is provided

**Behavior:**
- Uses a `Completer` internally to race between work completion and operation failure
- If `operationState` becomes `cleanup` or `failed`, invokes `onCrash` and returns its result
- If work completes normally, returns its result
- Does NOT use simple timeout - responds to actual operation state changes

**Example:**
```dart
final results = await operation.waitForCompletion<List<WorkerResult>>(
  () async => await _waitForWorkers(),
  onCrash: (info) async {
    print('Operation failed: ${info.reason}');
    await _cleanupPartialWork();
    return []; // Return empty list as fallback
  },
);

if (results != null) {
  print('Got ${results.length} worker results');
}
```

#### Spawn Call (Parallel Execution)

```dart
SpawnedCall<T> spawnCall<T>({
  required Future<T> Function() work,
  Future<T?> Function()? onCrash,
  Future<void> Function(T result)? onCompletion,
  String? description,
  bool failOnCrash = true,
})
```

Starts a call that runs asynchronously without blocking. The call executes in parallel with other spawned calls and can return a result.

**Type Parameter:**
- `T` - The return type of the work function

**Parameters:**
- `work` - The async function to execute, returns `Future<T>`
- `onCrash` - Optional callback invoked if this call crashes (e.g., exception thrown); can return a typed fallback value `T?` to use as the result
- `onCompletion` - Optional callback invoked when work completes successfully, receives result
- `description` - Optional human-readable description
- `failOnCrash` - Whether a crash in this call should fail the entire operation (default: `true`). If `false`, the call fails individually but the operation continues; `onCrash` can provide a fallback value.

**Returns:** `SpawnedCall<T>` object for tracking the call and retrieving its result

**Actions:**
1. Generates unique callId
2. Creates frame with `state = active` and `failOnCrash` flag
3. Returns `SpawnedCall<T>` immediately
4. Executes `work()` asynchronously
5. On success: stores result, calls `onCompletion`, removes frame
6. On exception: calls `onCrash`, marks call as failed via `failCall()`

**Note:** The spawned call manages its own lifecycle - caller does not need to call `endCall()`.

**Frame Ordering Note:** With spawned calls completing asynchronously, frames may not be removed in LIFO order. The stack may have gaps as spawned calls complete in any order. All frame operations (lookup, removal) must use `callId` for identification rather than assuming stack position.

---

### SpawnedCall Class

```dart
class SpawnedCall<T> {
  /// The call ID generated by the ledger
  final String callId;
  
  /// Whether the call has completed (successfully or failed)
  bool get isCompleted => _completer.isCompleted;
  
  /// Whether the call completed successfully (not crashed)
  bool get isSuccess => _isSuccess;
  
  /// Whether the call failed/crashed
  bool get isFailed => !_isSuccess && isCompleted;
  
  /// The result of the call (only valid if isSuccess is true)
  /// Throws StateError if accessed before completion or if call failed
  T get result {
    if (!isCompleted) throw StateError('Call not yet completed');
    if (!_isSuccess) throw StateError('Call failed, no result available');
    return _result as T;
  }
  
  /// The result if successful, null otherwise (safe accessor)
  /// Does not throw - returns null if not completed or failed
  T? get resultOrNull => isSuccess ? _result as T : null;
  
  /// The result if successful, or the provided default value
  /// Does not throw - returns defaultValue if not completed or failed
  T resultOr(T defaultValue) => isSuccess ? _result as T : defaultValue;
  
  /// Wait for this call to complete
  Future<void> get future => _completer.future;
  
  /// The error if the call failed (null if success or not completed)
  Object? get error => _error;
  
  /// The stack trace if the call failed (null if success or not completed)
  StackTrace? get stackTrace => _stackTrace;
}
```

#### Sync on Spawned Calls

```dart
Future<SyncResult> sync(
  List<SpawnedCall> calls, {
  Future<void> Function(OperationFailedInfo info)? onOperationFailed,
  Future<void> Function()? onCompletion,
})
```

Waits for all specified spawned calls to complete and collects their results.

**Parameters:**
- `calls` - List of `SpawnedCall` objects returned from `spawnCall()`
- `onOperationFailed` - Called if the entire operation fails (due to a call with `failOnCrash = true` crashing)
- `onCompletion` - Called when all calls complete (regardless of success/failure)

**Note:** Individual crash handling is done per-call via the `onCrash` callback in `spawnCall()`, which can also provide typed fallback values.

**Returns:** `SyncResult` containing completion status

**Behavior:**
- Waits until all specified calls have ended (normally or crashed)
- If a call crashes and has `failOnCrash = true`, the entire operation enters `failed` state
- If a call crashes and has `failOnCrash = false`, only that call fails; others continue
- When a call with `onCrash` callback crashes, the callback is invoked and its return value becomes the call's result (making it appear as "success" with fallback value)
- If operation enters `failed` state, invokes `onOperationFailed` and returns immediately
- Returns `SyncResult` when all calls have finished or operation has failed

**Note on timing:** When `operationFailed` is `true`, `sync()` returns immediately. At this point, some calls may still be running or in an unknown state:
- `successfulCalls` - Calls that completed successfully before the operation failed
- `failedCalls` - Calls that were detected as failed
- `unknownCalls` - Calls whose outcome is unknown (still running when operation failed)

---

### SyncResult Class

```dart
class SyncResult {
  /// Whether all calls completed successfully (no failures, no unknowns)
  bool get allSucceeded => failedCalls.isEmpty && unknownCalls.isEmpty && !operationFailed;
  
  /// Whether any calls failed
  bool get hasFailed => failedCalls.isNotEmpty;
  
  /// Whether the operation itself failed (not just individual calls)
  final bool operationFailed;
  
  /// List of calls that completed successfully before sync returned
  final List<SpawnedCall> successfulCalls;
  
  /// List of calls that failed/crashed before sync returned
  final List<SpawnedCall> failedCalls;
  
  /// List of calls whose outcome is unknown (operation failed before they completed)
  /// These calls may still be running, may complete, or may crash - their state is indeterminate
  final List<SpawnedCall> unknownCalls;
  
  /// Whether all tracked calls have a known outcome (no unknowns)
  bool get allResolved => unknownCalls.isEmpty;
}
```

**Example with failOnCrash:**
```dart
// Spawn calls with different failure modes
final spawned1 = operation.spawnCall<int>(
  work: () async => await computeValue1(),
  failOnCrash: true, // Default: crash here fails entire operation
  onCompletion: (result) async => print('Task 1 returned: $result'),
);

final spawned2 = operation.spawnCall<String>(
  work: () async => await computeValue2(),
  failOnCrash: false, // Crash here is contained
  onCrash: () async {
    print('Task 2 crashed, using fallback');
    return 'fallback-value'; // This becomes the result
  },
);

final spawned3 = operation.spawnCall<List<int>>(
  work: () async => await computeValue3(),
  failOnCrash: false,
  // No onCrash - if this crashes, result will be null/unavailable
);

final syncResult = await operation.sync(
  [spawned1, spawned2, spawned3],
  onOperationFailed: (info) async {
    print('Operation failed, aborting sync');
  },
);

if (syncResult.allSucceeded) {
  // Access results - each is typed according to SpawnedCall<T>
  int result1 = spawned1.result;       // int
  String result2 = spawned2.result;    // String - may be fallback value
  List<int> result3 = spawned3.result; // List<int>
  print('All results: $result1, $result2, $result3');
} else if (syncResult.operationFailed) {
  print('Operation failed before all calls completed');
  print('Successful: ${syncResult.successfulCalls.length}');
  print('Failed: ${syncResult.failedCalls.length}');
  print('Unknown: ${syncResult.unknownCalls.length}');
} else {
  print('${syncResult.failedCalls.length} calls failed');
  for (final failed in syncResult.failedCalls) {
    print('  ${failed.callId}: ${failed.error}');
  }
  // Use safe accessors for partial results
  for (final call in [spawned1, spawned2, spawned3]) {
    final value = call.resultOrNull;
    if (value != null) {
      print('  ${call.callId}: $value');
    }
  }
}
```

---

### Callback Structure

```dart
class CallCallback {
  /// Called by ledger during cleanup (crash or normal operation end)
  /// Use this to release resources, close connections, delete temp files, etc.
  final Future<void> Function() onCleanup;
  
  /// Optional: Called when call ends normally
  final Future<void> Function(CallEndedInfo info)? onEnded;
  
  /// Optional: Called when this call crashes (detected by another participant)
  final Future<void> Function(CrashedCallInfo info)? onCrashed;
}
```

**Note:** The `onCrashed` callback replaces the Supervisor's crash notification. Each call can have its own crash handler.

---

### CallInfo Classes

#### CallEndedInfo

Passed to `callback.onEnded()`:

```dart
class CallEndedInfo {
  final String callId;
  final String operationId;
  final String participantId;
  final DateTime startedAt;
  final DateTime endedAt;
  Duration get duration => endedAt.difference(startedAt);
}
```

#### CrashedCallInfo

Passed to `callback.onCrashed()`:

```dart
class CrashedCallInfo {
  final String callId;
  final String operationId;
  final String participantId;
  final DateTime startedAt;
  final DateTime detectedAt;
  Duration get uptime => detectedAt.difference(startedAt);
  final String? crashReason;
}
```

#### OperationFailedInfo

Passed to `onCrash` in `waitForCompletion()` and `onOperationFailed` in `sync()`:

```dart
class OperationFailedInfo {
  final String operationId;
  final DateTime failedAt;
  final String? reason;
  final List<String> crashedCallIds;
}
```

---

### Operation Logging API

```dart
/// Write an entry to the operation log
Future<void> log(String message, {LogLevel level = LogLevel.info});

/// Write an entry to the debug log (INTERNAL USE ONLY)
Future<void> debugLog(String message);
```

**Log levels:**
```dart
enum LogLevel { debug, info, warning, error }
```

The operation log is opened in append mode, allowing concurrent writes from multiple participants without conflicts.

**Note on debugLog:** The `debugLog()` method is for **internal ledger use only**, primarily for testing and debugging the ledger implementation itself. Application code (initiators and participants) should use `log()` instead. Debug logging may be disabled in production and should not be relied upon for application-level logging.

---

### Execute Call Helper

The `executeCall()` method is a convenience helper that combines the complete call sequence into a single operation. It handles joining, starting, executing work, waiting, and properly ending or failing the call.

```dart
Future<T?> executeCall<T>({
  required String operationId,
  required CallCallback callback,
  required Future<T?> Function(Operation operation) work,
  Future<T?> Function(Operation operation)? wait,
  Future<T?> Function(Operation operation, T? workResult)? process,
  Future<T?> Function(OperationFailedInfo info)? onCrash,
  String? description,
  bool failOnCrash = true,
})
```

**Type Parameter:**
- `T` - The return type of the call (nullable throughout since `null` is a valid result)

**Parameters:**
- `operationId` - The operation to join
- `callback` - Application callbacks for cleanup and crash notification
- `work` - The main work function; receives the Operation for logging; returns `Future<T?>`
- `wait` - Optional wait function for async workers (runs after work completes); returns `Future<T?>`
- `process` - Optional post-processing function; receives workResult and returns final `Future<T?>`
- `onCrash` - Called if operation fails; can return fallback value of type `T?`
- `description` - Optional human-readable description of this call
- `failOnCrash` - Whether a crash in this call should fail the entire operation (default: `true`)

**Returns:**
- Result of type `T?` on success (may be null)
- Result of `onCrash()` on operation failure
- `null` if operation fails and no `onCrash` is provided

**Internal Implementation:**

```dart
Future<T?> executeCall<T>({
  required String operationId,
  required CallCallback callback,
  required Future<T?> Function(Operation operation) work,
  Future<T?> Function(Operation operation)? wait,
  Future<T?> Function(Operation operation, T? workResult)? process,
  Future<T?> Function(OperationFailedInfo info)? onCrash,
  String? description,
  bool failOnCrash = true,
}) async {
  // 1. Join the operation
  final operation = await ledger.joinOperation(operationId: operationId);
  
  // 2. Start the call
  final callId = await operation.startCall(
    callback: callback,
    description: description,
    failOnCrash: failOnCrash,
  );
  
  try {
    // 3. Execute main work
    T? result = await work(operation);
    
    // 4. Optional wait (e.g., for triggered workers)
    if (wait != null) {
      result = await operation.waitForCompletion<T>(
        () => wait(operation),
        onCrash: onCrash,
      ) ?? result;
    }
    
    // 5. Optional post-processing
    if (process != null) {
      result = await process(operation, result);
    }
    
    // 6. End call successfully
    await operation.endCall(callId: callId);
    return result;
    
  } catch (e, st) {
    // 7. Fail call on exception
    await operation.failCall(callId: callId, error: e, stackTrace: st);
    
    // 8. Invoke onCrash if provided
    if (onCrash != null) {
      return await onCrash(OperationFailedInfo(
        operationId: operationId,
        failedAt: DateTime.now(),
        reason: e.toString(),
        crashedCallIds: [callId],
      ));
    }
    rethrow;
  }
}
```

**Example - Simple work execution:**

```dart
final result = await ledger.executeCall<ProcessResult?>(
  operationId: 'op_123',
  callback: CallCallback(
    onCleanup: () async => await _releaseResources(),
  ),
  description: 'Process document',
  work: (operation) async {
    await operation.log('Starting processing');
    return await _processDocument(inputPath);
  },
);
```

**Example - Trigger workers and wait for results:**

```dart
final results = await ledger.executeCall<List<WorkerResult>?>(
  operationId: operationId,
  callback: CallCallback(
    onCleanup: () async => await _killWorkers(),
  ),
  description: 'Coordinate build',
  
  // Trigger workers (returns list of handles)
  work: (operation) async {
    await operation.log('Spawning workers');
    await _spawnWorkers(operation.operationId, config);
    return <WorkerResult>[]; // Initial empty list
  },
  
  // Wait for workers to finish
  wait: (operation) async {
    await operation.log('Waiting for workers');
    return await _collectWorkerResults();
  },
  
  // Process results
  process: (operation, results) async {
    await operation.log('Processing ${results.length} results');
    return results.where((r) => r.success).toList();
  },
  
  // Handle operation failure
  onCrash: (info) async {
    print('Operation failed: ${info.reason}');
    return []; // Return empty list as fallback
  },
);
```

---

### OperationHelper Class

Static helper methods for common operation patterns.

#### Poll for File

```dart
static Future<T> Function() pollFile<T>({
  required String path,
  bool delete = false,
  T Function(String content)? deserializer,
  Duration pollInterval = const Duration(milliseconds: 100),
  Duration? timeout,
})
```

Creates a wait function that polls for a file to appear, reads its contents, and optionally parses it.

**Type Parameter:**
- `T` - The return type (usually `String`, `Map<String, dynamic>`, or a custom type)

**Parameters:**
- `path` - Absolute path to the file to wait for
- `delete` - Whether to delete the file after reading (default: `false`)
- `deserializer` - Optional function to parse file content; if null and `T` is `String`, returns raw content; if null and `T` is `Map`, uses `jsonDecode`
- `pollInterval` - How often to check for file (default: 100ms)
- `timeout` - Optional timeout; throws `TimeoutException` if exceeded; `null` means wait forever

**Returns:** A function suitable for use as the `wait` parameter in `executeCall()` or `waitForCompletion()`

**Behavior:**
1. Polls for file existence at `pollInterval`
2. When file appears, reads entire content
3. If `delete` is true, deletes file after reading
4. If `T` is `String` and no deserializer, returns raw content
5. If `T` is `Map<String, dynamic>` and no deserializer, uses `jsonDecode(content)`
6. If deserializer provided, calls `deserializer(content)`

**Example - Wait for string result:**

```dart
final content = await operation.waitForCompletion<String>(
  OperationHelper.pollFile<String>(
    path: '/tmp/worker_result.txt',
    delete: true,
  ),
);
```

**Example - Wait for JSON result:**

```dart
final result = await operation.waitForCompletion<Map<String, dynamic>>(
  OperationHelper.pollFile<Map<String, dynamic>>(
    path: '/tmp/result.json',
    delete: true,
    timeout: Duration(seconds: 30),
  ),
);
```

**Example - Wait for typed object:**

```dart
final result = await operation.waitForCompletion<BuildResult>(
  OperationHelper.pollFile<BuildResult>(
    path: '/tmp/build_result.json',
    delete: true,
    deserializer: (content) => BuildResult.fromJson(jsonDecode(content)),
  ),
);
```

#### Poll with Custom Condition

```dart
static Future<T> Function() pollUntil<T>({
  required Future<T?> Function() check,
  Duration pollInterval = const Duration(milliseconds: 100),
  Duration? timeout,
})
```

Creates a wait function that polls until a condition returns a non-null value.

**Parameters:**
- `check` - Function that returns `null` to continue polling, or a value to complete
- `pollInterval` - How often to check (default: 100ms)
- `timeout` - Optional timeout

**Example - Wait for process to complete:**

```dart
final exitCode = await operation.waitForCompletion<int>(
  OperationHelper.pollUntil<int>(
    check: () async {
      final code = await process.exitCode;
      return code != null ? code : null;
    },
    timeout: Duration(minutes: 5),
  ),
);
```

#### Wait for Multiple Files

```dart
static Future<List<T>> Function() pollFiles<T>({
  required List<String> paths,
  bool delete = false,
  T Function(String content)? deserializer,
  Duration pollInterval = const Duration(milliseconds: 100),
  Duration? timeout,
})
```

Creates a wait function that waits for multiple files to appear and returns all their contents.

**Example:**

```dart
final results = await operation.waitForCompletion<List<WorkerResult>>(
  OperationHelper.pollFiles<WorkerResult>(
    paths: workerOutputPaths,
    delete: true,
    deserializer: (content) => WorkerResult.fromJson(jsonDecode(content)),
  ),
);
```

---

## Data Structures

### Operation File Structure

```json
{
  "operationId": "20260121T12:00:00.000-cli-a1b2c3d4",
  "operationState": "running",
  "initiatorId": "cli",
  "lastHeartbeat": "2026-01-21T12:00:00Z",
  "detectionTimestamp": null,
  "removalTimestamp": null,
  "stack": [
    {
      "callId": "call_001",
      "participantId": "cli",
      "state": "active",
      "failOnCrash": true,
      "lastHeartbeat": "2026-01-21T12:00:00Z",
      "description": "tom build --watch",
      "resources": []
    },
    {
      "callId": "call_002",
      "participantId": "vscode-bridge",
      "state": "active",
      "failOnCrash": false,
      "lastHeartbeat": "2026-01-21T12:00:00Z",
      "description": "Execute script: process_doc.dart",
      "resources": ["_ai/temp/req_123.json"]
    }
  ]
}
```

### Frame Field Reference

| Field | Type | Description |
|-------|------|-------------|
| `callId` | string | Unique identifier for this call |
| `participantId` | string | ID of the participant that owns this call |
| `state` | enum | Frame state: `active`, `crashed`, `cleaningUp`, `cleanedUp` |
| `failOnCrash` | boolean | Whether a crash in this call fails the entire operation (default: `true`) |
| `lastHeartbeat` | datetime | Last heartbeat timestamp for this frame |
| `description` | string? | Optional human-readable description |
| `resources` | string[] | Temporary resources to clean up |

### Operation States

```dart
enum OperationState {
  /// Operation is running normally
  running,
  
  /// Crash detected, cleanup in progress
  cleanup,
  
  /// Cleanup complete, operation failed
  failed,
  
  /// Operation completed successfully
  completed,
}
```

### Frame States

```dart
enum FrameState {
  /// Frame is executing normally
  active,
  
  /// Frame's participant has crashed
  crashed,
  
  /// Frame marked as cleanup coordinator
  cleaningUp,
  
  /// Frame has completed cleanup
  cleanedUp,
}
```

---

## Operation Logging

### Log Files

Each operation has two log files:

| File | Purpose | Format |
|------|---------|--------|
| `*.operation.log` | Human-readable operation events | Timestamped lines |
| `*.operation.debug.log` | Detailed debug output | Timestamped lines |

### Log File Format

```
2026-01-21T12:00:00.123Z [INFO] CALL_STARTED callId=call_001 participant=cli
2026-01-21T12:00:05.456Z [INFO] CALL_STARTED callId=call_002 participant=vscode-bridge
2026-01-21T12:00:10.789Z [INFO] CALL_ENDED callId=call_001 duration=10.666s
2026-01-21T12:00:15.012Z [ERROR] CRASH_DETECTED callId=call_002 reason=stale_heartbeat
2026-01-21T12:00:15.123Z [INFO] CLEANUP_STARTED coordinator=cli
2026-01-21T12:00:20.456Z [INFO] OPERATION_FAILED
```

### Write Mode

Log files are opened in **append mode** to allow concurrent writes from multiple participants without locking conflicts.

### Lifecycle Events

| Event | Description |
|-------|-------------|
| `OPERATION_CREATED` | New operation started by initiator |
| `PARTICIPANT_JOINED` | Participant joined existing operation |
| `CALL_STARTED` | New call started |
| `CALL_ENDED` | Call ended normally |
| `CRASH_DETECTED` | Stale heartbeat detected |
| `CLEANUP_STARTED` | Coordinator began cleanup |
| `CALL_CRASHED` | Call marked as crashed |
| `OPERATION_FAILED` | Operation ended due to crash |
| `OPERATION_COMPLETED` | Operation completed successfully |

---

## Backup and Cleanup

### Backup Mechanism

When an operation ends (completed or failed), all operation files are moved to a per-operation backup folder:

```
_ai/ops_ledger/backup/
├── 20260121T12:00:00.000-cli-a1b2c3d4/
│   ├── operation.json
│   ├── operation.log
│   └── operation.debug.log
├── 20260121T12:05:00.000-cli-b2c3d4e5/
│   ├── operation.json
│   ├── operation.log
│   └── operation.debug.log
└── ...
```

Each operation's files are stored in a folder named with the operationId. This makes cleanup simpler as we count folders (operations) rather than files.

### Backup Cleanup

The ledger automatically cleans old backups during operation cleanup:

1. **Trigger:** After moving files to backup (Phase 4 of cleanup or normal completion)
2. **Action:** List all backup folders, sorted by timestamp (from folder name)
3. **Retention:** Keep only the most recent `maxBackups` operations (default: 20)
4. **Deletion:** Remove entire folder for operations beyond the retention limit

```dart
// Configuration in Ledger.initLedger()
await Ledger.initLedger(
  participantId: 'my-service',
  maxBackups: 20,  // Keep last 20 operations
);
```

### Backup Cleanup Algorithm

```dart
Future<void> _cleanOldBackups() async {
  final backupDir = Directory('$ledgerPath/backup');
  if (!await backupDir.exists()) return;
  
  // Get all operation folders
  final folders = await backupDir
    .list()
    .where((e) => e is Directory)
    .cast<Directory>()
    .toList();
  
  // Extract operation IDs (folder names) and sort by timestamp
  final operationIds = folders
    .map((d) => path.basename(d.path))
    .toList();
  operationIds.sort((a, b) => b.compareTo(a));  // Newest first
  
  // Delete operation folders beyond retention limit
  if (operationIds.length > _maxBackups) {
    final toDelete = operationIds.skip(_maxBackups);
    for (final opId in toDelete) {
      final folder = Directory(path.join(backupDir.path, opId));
      await folder.delete(recursive: true);
    }
  }
}
```

---

## Cleanup Mechanism

### Design Principles

The cleanup mechanism is **sequential and coordinator-based**:

- **Single coordinator** - First to detect crash coordinates entire cleanup
- **Four phases** - Detection → Self-Cleanup → Frame Removal → Backup
- **Fixed timing** - Each phase separated by heartbeat intervals
- **Callback-based crash notification** - Each call has its own `onCrashed` callback

### Timing Constants

| Constant | Value | Purpose |
|----------|-------|---------|
| Heartbeat interval | 4-5 seconds (with jitter) | Time between heartbeats |
| Staleness threshold | 10 seconds | Time before frame considered dead |
| Self-cleanup window | 2 heartbeats (~10s) | Time for participants to self-cleanup |
| File deletion delay | 2 heartbeats (~10s) | Time before moving to backup |

### Phase Overview

```
T+0: Crash occurs (heartbeat stops)
T+2: Phase 1 - Detection (coordinator marks crash, signals cleanup)
T+3: Phase 2 - Self-Cleanup Window (others cleanup themselves)
T+4: Phase 3 - Frame Removal (coordinator removes remaining frames)
T+6: Phase 4 - Backup (coordinator moves files to backup, cleans old backups)
```

---

### Phase 1: Detection

**Trigger:** Call heartbeat detects stale frame (heartbeat > 10s old)

**First detector becomes coordinator:**

1. **Lock operation file**
2. **Mark crashed frames** → `state = crashed`
3. **Check failOnCrash attribute:**
   - If ANY crashed frame has `failOnCrash = true`: proceed with full operation cleanup
   - If ALL crashed frames have `failOnCrash = false`: handle as contained crash (see below)
4. **Mark all other frames** → `state = cleanup` (signals them to self-cleanup)
5. **Set operation state** → `operationState = cleanup`
6. **Log** → "CRASH_DETECTED" and "CLEANUP_STARTED" to operation log
7. **Perform own cleanup:**
   - Call `callback.onCleanup()` on own frame
   - Call `frame.cleanup()` (deletes temp resources)
   - Set own frame `state = cleaningUp` (marks as coordinator)
8. **Record timestamp** → `detectionTimestamp = now()`
9. **Release lock**
10. **Continue heartbeating** (coordinator role)

**Important:** Other participants are NOT yet notified. They will detect the state change in their next heartbeat.

---

### Contained Crash Handling (failOnCrash = false)

When a crashed frame has `failOnCrash = false`, the crash is contained and does not trigger full operation cleanup:

**Detection:**
1. First heartbeat to detect stale frame marks it as `state = crashed`
2. Since `failOnCrash = false`, operation does NOT enter cleanup state
3. Log "CALL_CRASHED (contained)" to operation log

**Cleanup timing:**
- **First option:** Next heartbeat after detection cleans up the crashed frame
- **Second option:** When the operation ends normally (via `completeOperation()`)
- Whichever comes first

**Cleanup actions (for contained crash):**
1. Call `frame.cleanup()` (deletes temp resources)
2. Call `callback.onCrashed()` if available
3. Set frame `state = cleanedUp`
4. Remove frame from stack
5. Log "CALL_CLEANED_UP (contained)" to operation log

**Note:** The operation continues running. Other calls are not affected. The SpawnedCall for this frame will have `isFailed = true` and its `onCrash` callback (if provided) will be invoked to provide a fallback value.

---

### Phase 2: Self-Cleanup Window

**Trigger:** Participant heartbeat detects `operationState = cleanup`

**Non-coordinator calls:**

1. Detect `operationState = cleanup`
2. Call `callback.onCleanup()` on own frame
3. Call `frame.cleanup()` (deletes temp resources)
4. Set own frame `state = cleanedUp`
5. Log "CALL_ENDED" (cleanup) to operation log
6. **Stop heartbeating**

**Crashed call notification (by coordinator):**

1. For each crashed frame, if `callback.onCrashed` is available:
   - Call `callback.onCrashed(CrashedCallInfo)`
2. Log "CALL_CRASHED" for each crashed call

---

### Phase 3: Frame Removal

**Trigger:** Coordinator detects `now() - detectionTimestamp >= 2 * heartbeatInterval`

**Coordinator actions:**

1. **Lock operation file**
2. **Cleanup remaining frames** (still in cleanup/crashed state)
   - Call `frame.cleanup()` on each
3. **Remove all frames** from stack
4. **Set operation state** → `operationState = failed`
5. **Log** → "OPERATION_FAILED" to operation log
6. **Record timestamp** → `removalTimestamp = now()`
7. **Release lock**

At this point, all other participants should have stopped heartbeating.

---

### Phase 4: Backup

**Trigger:** Coordinator detects `now() - removalTimestamp >= 2 * heartbeatInterval`

**Coordinator actions:**

1. **Move operation files** to backup folder
2. **Clean old backups** beyond retention limit
3. **Stop heartbeating**

The extra delay allows any remaining participants to detect the `failed` state before the files are moved.

---

## API Usage Examples

### Example 1: Simple Call with Parameter and Result

```dart
// Application startup
await Ledger.initLedger(
  participantId: 'document-processor',
  maxBackups: 20,
);

// Execute a call with input parameters and return result
Future<ProcessResult> processDocument(String operationId, DocumentRequest request) async {
  final ledger = Ledger.instance;
  final operation = await ledger.joinOperation(operationId: operationId);
  
  // Create callback for cleanup and crash notification
  final callback = CallCallback(
    cleanup: () async {
      // Release resources, close connections, etc.
      await _releaseResources();
      await _deleteTempFiles(request.tempPath);
    },
    onEnded: (info) async {
      print('Processed ${request.documentPath} in ${info.duration.inMilliseconds}ms');
    },
    onCrashed: (info) async {
      print('Processing crashed after ${info.uptime.inSeconds}s');
      await _handleCrash();
    },
  );
  
  // Start the call - ledger generates callId
  final callId = await operation.startCall(
    callback: callback,
    description: 'Process ${request.documentPath}',
  );
  
  try {
    // Log progress with parameters
    await operation.log('Processing started: ${request.documentPath}');
    
    // Do the work - accepts parameters, returns result
    final result = await _processDocument(
      path: request.documentPath,
      options: request.options,
      outputPath: request.outputPath,
    );
    
    await operation.log('Processing completed: ${result.pageCount} pages');
    
    // End normally
    await operation.endCall(callId: callId);
    
    return result;
  } catch (e, st) {
    // IMPORTANT: Use failCall() for explicit failure handling
    // If we just rethrow, the heartbeat continues and failure is never detected!
    await operation.failCall(callId: callId, error: e, stackTrace: st);
    rethrow;
  }
}
```

### Example 2: Initiator Creating Operation with Results

```dart
// Initiator creates a new operation and collects results
Future<BuildResult> startDistributedBuild(BuildConfig config) async {
  final ledger = Ledger.instance;
  
  // Create new operation
  final operation = await ledger.createOperation(
    description: 'Build project: ${config.projectName}',
  );
  
  print('Created operation: ${operation.operationId}');
  // Example: 20260121T14:30:45.123-cli-a1b2c3d4
  
  // Start initiator's own call
  final callId = await operation.startCall(
    callback: CallCallback(
      cleanup: () async => await _cleanup(),
    ),
    description: 'Coordinate build',
  );
  
  try {
    // Spawn workers with config, passing operation.operationId
    final workerHandles = await _spawnWorkers(
      operationId: operation.operationId,
      config: config,
    );
    
    // Wait for work to complete - with crash awareness
    // This does NOT use a simple timeout - it responds to operation state changes
    List<WorkerResult>? workerResults;
    await operation.waitForCompletion(
      () async {
        workerResults = await _waitForWorkers(workerHandles);
      },
      onCrash: (info) async {
        print('Operation crashed: ${info.reason}');
        // Cleanup is already being handled by the ledger
      },
    );
    
    // End our call
    await operation.endCall(callId: callId);
    
    // Complete the operation (moves to backup)
    await operation.completeOperation();
    
    // Return aggregated results
    return BuildResult(
      operationId: operation.operationId,
      workers: workerResults ?? [],
      totalTime: DateTime.now().difference(operation.startTime),
    );
  } catch (e, st) {
    // Explicit failure - don't rely on stale heartbeat
    await operation.failCall(callId: callId, error: e, stackTrace: st);
    rethrow;
  }
}
```

### Example 3: Sequential Calls with Parameters and Results

```dart
// Start multiple calls sequentially - each with parameters and results
Future<PipelineResult> runPipeline(String operationId, PipelineInput input) async {
  final operation = await ledger.joinOperation(operationId: operationId);
  
  // Step 1: Parse input
  final parseCallId = await operation.startCall(
    callback: CallCallback(cleanup: () async => await _cleanupParser()),
    description: 'Parse input',
  );
  
  ParseResult parseResult;
  try {
    parseResult = await _parseInput(input.rawData, options: input.parseOptions);
    await operation.endCall(callId: parseCallId);
  } catch (e, st) {
    await operation.failCall(callId: parseCallId, error: e, stackTrace: st);
    rethrow;
  }
  
  // Step 2: Transform (uses result from step 1)
  final transformCallId = await operation.startCall(
    callback: CallCallback(cleanup: () async => await _cleanupTransformer()),
    description: 'Transform data',
  );
  
  TransformResult transformResult;
  try {
    transformResult = await _transform(
      parseResult.ast,
      rules: input.transformRules,
    );
    await operation.endCall(callId: transformCallId);
  } catch (e, st) {
    await operation.failCall(callId: transformCallId, error: e, stackTrace: st);
    rethrow;
  }
  
  // Step 3: Output (uses result from step 2)
  final outputCallId = await operation.startCall(
    callback: CallCallback(cleanup: () async => await _cleanupOutput()),
    description: 'Generate output',
  );
  
  try {
    final outputPath = await _generateOutput(
      transformResult.data,
      format: input.outputFormat,
    );
    await operation.endCall(callId: outputCallId);
    
    return PipelineResult(
      outputPath: outputPath,
      recordsProcessed: transformResult.recordCount,
    );
  } catch (e, st) {
    await operation.failCall(callId: outputCallId, error: e, stackTrace: st);
    rethrow;
  }
}
```

### Example 4: Parallel Calls with Spawn, Sync, and Typed Results

```dart
// Spawn multiple typed calls that run in parallel and collect results
Future<BatchResult> processBatch(String operationId, List<Document> documents) async {
  final operation = await ledger.joinOperation(operationId: operationId);

  // Spawn typed calls - returns immediately with SpawnedCall<T>
  // The work functions run asynchronously in parallel
  final spawned1 = await operation.spawnCall<DocumentResult>(
    work: () => _processDocument(documents[0]),
    callback: CallCallback(
      cleanup: () async => await _cleanup(documents[0].tempPath),
      onCrashed: (info) async => print('Doc 1 crashed after ${info.uptime}'),
    ),
    description: 'Process ${documents[0].name}',
  );
  
  final spawned2 = await operation.spawnCall<DocumentResult>(
    work: () => _processDocument(documents[1]),
    callback: CallCallback(
      cleanup: () async => await _cleanup(documents[1].tempPath),
    ),
    description: 'Process ${documents[1].name}',
  );
  
  final spawned3 = await operation.spawnCall<DocumentResult>(
    work: () => _processDocument(documents[2]),
    callback: CallCallback(
      cleanup: () async => await _cleanup(documents[2].tempPath),
    ),
    description: 'Process ${documents[2].name}',
  );

  // All three calls are now running in parallel
  // Sync on all of them - waits for all to complete, returns SyncResult
  final syncResult = await operation.sync(
    [spawned1, spawned2, spawned3],
    onCrash: (callId, info) async {
      print('Call $callId crashed after ${info.uptime.inSeconds}s');
    },
    onOperationFailed: (info) async {
      print('Entire operation failed');
    },
  );

  // Check results
  if (syncResult.allSucceeded) {
    // Access typed results directly
    final result1 = spawned1.result; // DocumentResult
    final result2 = spawned2.result; // DocumentResult
    final result3 = spawned3.result; // DocumentResult
    
    return BatchResult(
      results: [result1, result2, result3],
      totalPages: result1.pageCount + result2.pageCount + result3.pageCount,
    );
  } else {
    // Handle partial failures
    print('${syncResult.failedCalls.length} calls failed');
    
    // Get results only from successful calls
    final successfulResults = syncResult.successfulCalls
        .map((s) => (s as SpawnedCall<DocumentResult>).result)
        .toList();
    
    // Log failed calls
    for (final failed in syncResult.failedCalls) {
      print('Call ${failed.callId} failed: ${failed.error}');
    }
    
    return BatchResult(
      results: successfulResults,
      totalPages: successfulResults.fold(0, (sum, r) => sum + r.pageCount),
      hasErrors: true,
    );
  }
}
```

### Example 5: Using Operation Log

```dart
final operation = await ledger.joinOperation(operationId: operationId);

// Log to operation log (visible in backup)
await operation.log('Starting document processing');
await operation.log('Processed 50 files', level: LogLevel.info);
await operation.log('Skipped invalid file: foo.txt', level: LogLevel.warning);

// Note: debugLog() is for INTERNAL ledger testing only
// Application code should use log() instead
```

---

## Implementation Reference

### Heartbeat Loop (Pseudo-code)

The single heartbeat loop handles crash detection and cleanup:

```dart
Future<void> _heartbeatLoop() async {
  while (_running) {
    await _performHeartbeat();
    
    // Random jitter: 4000-5000ms
    final delay = 4000 + _random.nextInt(1000);
    await Future.delayed(Duration(milliseconds: delay));
  }
}

Future<void> _performHeartbeat() async {
  final data = await operation.retrieveAndLockOperation();
  if (data == null) {
    _stopHeartbeat();
    return;
  }
  
  // Check for stale frames (crash detection)
  var foundCrash = false;
  for (var frame in data.stack) {
    if (frame.isStale(thresholdMs: stalenessThresholdMs)) {
      foundCrash = true;
      frame.state = FrameState.crashed;
    }
  }
  
  if (foundCrash && data.operationState == OperationState.running) {
    // First detector becomes coordinator
    await _becomeCoordinator(data);
    return;
  }
  
  // React to cleanup state if already in cleanup
  if (data.operationState == OperationState.cleanup) {
    await _handleCleanupState(data);
    return;
  }
  
  // Update heartbeat timestamp
  data.lastHeartbeat = DateTime.now();
  for (var frame in data.stack.where((f) => f.participantId == participantId)) {
    frame.lastHeartbeat = DateTime.now();
  }
  
  await operation.writeAndUnlockOperation(data);
}
```

### Coordinator Cleanup (Pseudo-code)

```dart
Future<void> _becomeCoordinator(OperationData data) async {
  // Log crash detection
  await operation.log('CRASH_DETECTED', level: LogLevel.error);
  await operation.log('CLEANUP_STARTED coordinator=$participantId');
  
  // Mark all non-crashed frames for cleanup
  for (var frame in data.stack) {
    if (frame.state == FrameState.active) {
      frame.state = FrameState.cleanup;
    }
  }
  
  // Perform own cleanup
  final myFrame = data.stack.firstWhere((f) => f.callId == _currentCallId);
  await _callbackMap[myFrame.callId]?.cleanup();
  await myFrame.cleanup();
  myFrame.state = FrameState.cleaningUp;  // Mark as coordinator
  
  // Set operation to cleanup state
  data.operationState = OperationState.cleanup;
  data.detectionTimestamp = DateTime.now();
  
  await operation.writeAndUnlockOperation(data);
  
  // Continue heartbeating for Phase 3 and 4
}
```

### Crash Notification (Pseudo-code)

```dart
Future<void> _notifyCrashedCalls(OperationData data) async {
  for (var frame in data.stack) {
    if (frame.state == FrameState.crashed) {
      final callback = _callbackMap[frame.callId];
      if (callback?.onCrashed != null) {
        final info = CrashedCallInfo(
          callId: frame.callId,
          operationId: data.operationId,
          participantId: frame.participantId,
          startedAt: frame.startedAt,
          detectedAt: data.detectionTimestamp!,
        );
        await callback!.onCrashed!(info);
      }
      await operation.log('CALL_CRASHED callId=${frame.callId}');
    }
  }
}
```

### Backup Handler (Pseudo-code)

```dart
Future<void> _performBackup(String operationId) async {
  final backupDir = Directory('$ledgerPath/backup');
  await backupDir.create(recursive: true);
  
  // Move all operation files to backup
  final files = [
    '$operationId.operation.json',
    '$operationId.operation.log',
    '$operationId.operation.debug.log',
  ];
  
  for (final filename in files) {
    final source = File('$ledgerPath/$filename');
    if (await source.exists()) {
      await source.rename('${backupDir.path}/$filename');
    }
  }
  
  // Clean old backups
  await _cleanOldBackups();
}
```

---

## Comparison: Previous vs Current Design

| Aspect | Previous | Current |
|--------|----------|---------|
| Supervisor | Separate abstract class | Removed - callbacks on call |
| Call ID generation | Application provides | Ledger generates |
| Supervisor handle | Returned by supervisor | Removed |
| Crash notification | Via supervisor | Via call callback |
| File format | JSON | JSON |
| Operation ID | `op_YYYYMMDD_HHMMSS_xxxx` | `YYYYMMDDTHH:MM:SS.sss-participant-xxxx` |
| File deletion | Delete after cleanup | Move to backup |
| Backup cleanup | Not specified | Configurable retention (default: 20) |
| Operation logging | Not specified | Append-mode log files |

---

## Benefits

✅ **Simpler API** - No Supervisor class, callbacks directly on calls  
✅ **Ledger-managed IDs** - No need to generate callIds  
✅ **Better traceability** - Operation ID contains timestamp and initiator  
✅ **Persistent history** - Backups preserved with configurable retention  
✅ **Operation logging** - Events recorded for debugging and auditing  
✅ **Predictable timing** - Fixed heartbeat intervals, known cleanup windows  
✅ **No race conditions** - File lock prevents concurrent modifications  
✅ **Testable** - Each phase is independently verifiable  

---

## Implementation Checklist

- [ ] Define `OperationState` and `FrameState` enums
- [ ] Implement `CallCallback` class with cleanup, onEnded, onCrashed
- [ ] Implement `CallEndedInfo`, `CrashedCallInfo`, and `OperationFailedInfo` classes
- [ ] Implement `Ledger.initLedger()` with maxBackups parameter
- [ ] Implement `createOperation()` with new ID format
- [ ] Implement `joinOperation()`
- [ ] Implement `startCall()` with ledger-generated callId
- [ ] Implement `endCall()`
- [ ] Implement `completeOperation()`
- [ ] Implement `waitForCompletion()` with Completer-based interruption
- [ ] Implement `spawnCall()` for parallel call execution
- [ ] Implement `sync()` for waiting on multiple spawned calls
- [ ] Implement `log()` method for operation logging
- [ ] Implement `debugLog()` method (internal use only)
- [ ] Implement unified heartbeat loop
- [ ] Implement Phase 1: Detection and coordinator selection
- [ ] Implement Phase 2: Self-cleanup with crash notification
- [ ] Implement Phase 3: Frame removal
- [ ] Implement Phase 4: Backup and old backup cleanup
- [ ] Write unit tests for each phase
- [ ] Write integration tests for multi-participant scenarios

