/// Data classes for call callbacks and info structures.
///
/// These classes support the callback pattern for cleanup and crash notification.
library;

import 'dart:async';
import 'dart:convert';
import 'dart:io';

/// Callback structure for call operations.
///
/// Provides hooks for cleanup and notifications during call lifecycle.
class CallCallback {
  /// Called by ledger during cleanup (crash or normal operation end).
  /// Use this to release resources, close connections, delete temp files, etc.
  final Future<void> Function() onCleanup;

  /// Optional: Called when call ends normally.
  final Future<void> Function(CallEndedInfo info)? onEnded;

  /// Optional: Called when this call crashes (detected by another participant).
  final Future<void> Function(CrashedCallInfo info)? onCrashed;

  CallCallback({
    required this.onCleanup,
    this.onEnded,
    this.onCrashed,
  });
}

/// Information passed to [CallCallback.onEnded] when a call completes normally.
class CallEndedInfo {
  /// The unique identifier for this call.
  final String callId;

  /// The operation this call belongs to.
  final String operationId;

  /// The participant that made this call.
  final String participantId;

  /// When the call started.
  final DateTime startedAt;

  /// When the call ended.
  final DateTime endedAt;

  CallEndedInfo({
    required this.callId,
    required this.operationId,
    required this.participantId,
    required this.startedAt,
    required this.endedAt,
  });

  /// Duration of the call.
  Duration get duration => endedAt.difference(startedAt);

  @override
  String toString() =>
      'CallEndedInfo(callId: $callId, duration: ${duration.inMilliseconds}ms)';
}

/// Information passed to [CallCallback.onCrashed] when a call crashes.
class CrashedCallInfo {
  /// The unique identifier for the crashed call.
  final String callId;

  /// The operation this call belongs to.
  final String operationId;

  /// The participant that made this call.
  final String participantId;

  /// When the call started.
  final DateTime startedAt;

  /// When the crash was detected.
  final DateTime detectedAt;

  /// The reason for the crash, if known.
  final String? crashReason;

  CrashedCallInfo({
    required this.callId,
    required this.operationId,
    required this.participantId,
    required this.startedAt,
    required this.detectedAt,
    this.crashReason,
  });

  /// How long the call was running before the crash was detected.
  Duration get uptime => detectedAt.difference(startedAt);

  @override
  String toString() =>
      'CrashedCallInfo(callId: $callId, uptime: ${uptime.inMilliseconds}ms, reason: $crashReason)';
}

/// Information about an operation failure.
///
/// Passed to crash callbacks in [Operation.waitForCompletion] and [Operation.sync].
class OperationFailedInfo {
  /// The operation that failed.
  final String operationId;

  /// When the failure was detected.
  final DateTime failedAt;

  /// The reason for the failure, if known.
  final String? reason;

  /// List of call IDs that crashed.
  final List<String> crashedCallIds;

  OperationFailedInfo({
    required this.operationId,
    required this.failedAt,
    this.reason,
    this.crashedCallIds = const [],
  });

  @override
  String toString() =>
      'OperationFailedInfo(operationId: $operationId, crashedCallIds: $crashedCallIds, reason: $reason)';
}

/// Log levels for operation logging.
enum LogLevel {
  debug,
  info,
  warning,
  error,
}

/// Extension to convert LogLevel to string.
extension LogLevelExtension on LogLevel {
  String get name => switch (this) {
        LogLevel.debug => 'DEBUG',
        LogLevel.info => 'INFO',
        LogLevel.warning => 'WARNING',
        LogLevel.error => 'ERROR',
      };
}

// ═══════════════════════════════════════════════════════════════════
// SPAWNED CALL CLASS
// ═══════════════════════════════════════════════════════════════════

/// Represents a call that was spawned asynchronously.
///
/// This class tracks the state and result of a spawned call.
class SpawnedCall<T> {
  /// The call ID generated by the ledger.
  final String callId;

  /// Optional description of this call.
  final String? description;

  /// Internal completer for waiting on this call.
  final Completer<void> _completer = Completer<void>();

  /// Whether the call succeeded.
  bool _isSuccess = false;

  /// The result of the call.
  T? _result;

  /// The error if the call failed.
  Object? _error;

  /// The stack trace if the call failed.
  StackTrace? _stackTrace;

  SpawnedCall({
    required this.callId,
    this.description,
  });

  /// Whether the call has completed (successfully or failed).
  bool get isCompleted => _completer.isCompleted;

  /// Whether the call completed successfully (not crashed).
  bool get isSuccess => _isSuccess;

  /// Whether the call failed/crashed.
  bool get isFailed => !_isSuccess && isCompleted;

  /// The result of the call (only valid if isSuccess is true).
  /// Throws StateError if accessed before completion or if call failed.
  T get result {
    if (!isCompleted) throw StateError('Call not yet completed');
    if (!_isSuccess) throw StateError('Call failed, no result available');
    return _result as T;
  }

  /// The result if successful, null otherwise (safe accessor).
  /// Does not throw - returns null if not completed or failed.
  T? get resultOrNull => isSuccess ? _result : null;

  /// The result if successful, or the provided default value.
  /// Does not throw - returns defaultValue if not completed or failed.
  T resultOr(T defaultValue) => isSuccess ? (_result ?? defaultValue) : defaultValue;

  /// Wait for this call to complete.
  Future<void> get future => _completer.future;

  /// The error if the call failed (null if success or not completed).
  Object? get error => _error;

  /// The stack trace if the call failed (null if success or not completed).
  StackTrace? get stackTrace => _stackTrace;

  /// Complete this call successfully with the given result.
  void complete(T result) {
    if (_completer.isCompleted) return;
    _result = result;
    _isSuccess = true;
    _completer.complete();
  }

  /// Fail this call with the given error.
  void fail(Object error, [StackTrace? stackTrace]) {
    if (_completer.isCompleted) return;
    _error = error;
    _stackTrace = stackTrace;
    _isSuccess = false;
    _completer.complete();
  }

  @override
  String toString() => 'SpawnedCall<$T>(callId: $callId, completed: $isCompleted, success: $isSuccess)';
}

// ═══════════════════════════════════════════════════════════════════
// SYNC RESULT CLASS
// ═══════════════════════════════════════════════════════════════════

/// Result of a [Operation.sync] call.
///
/// Contains information about which calls succeeded, failed, or have unknown state.
class SyncResult {
  /// List of calls that completed successfully before sync returned.
  final List<SpawnedCall> successfulCalls;

  /// List of calls that failed/crashed before sync returned.
  final List<SpawnedCall> failedCalls;

  /// List of calls whose outcome is unknown (operation failed before they completed).
  /// These calls may still be running, may complete, or may crash.
  final List<SpawnedCall> unknownCalls;

  /// Whether the operation itself failed (not just individual calls).
  final bool operationFailed;

  SyncResult({
    this.successfulCalls = const [],
    this.failedCalls = const [],
    this.unknownCalls = const [],
    this.operationFailed = false,
  });

  /// Whether all calls completed successfully (no failures, no unknowns).
  bool get allSucceeded => failedCalls.isEmpty && unknownCalls.isEmpty && !operationFailed;

  /// Whether any calls failed.
  bool get hasFailed => failedCalls.isNotEmpty;

  /// Whether all tracked calls have a known outcome (no unknowns).
  bool get allResolved => unknownCalls.isEmpty;

  @override
  String toString() =>
      'SyncResult(success: ${successfulCalls.length}, failed: ${failedCalls.length}, unknown: ${unknownCalls.length}, operationFailed: $operationFailed)';
}

// ═══════════════════════════════════════════════════════════════════
// OPERATION HELPER CLASS
// ═══════════════════════════════════════════════════════════════════

/// Static helper methods for common operation patterns.
///
/// Provides utilities for polling files, waiting for conditions,
/// and other common async patterns used with the ledger API.
class OperationHelper {
  OperationHelper._(); // Prevent instantiation

  /// Creates a wait function that polls for a file to appear.
  ///
  /// Returns a function suitable for use with [Operation.waitForCompletion].
  ///
  /// Parameters:
  /// - [path] - Absolute path to the file to wait for
  /// - [delete] - Whether to delete the file after reading (default: `false`)
  /// - [deserializer] - Optional function to parse file content
  /// - [pollInterval] - How often to check for file (default: 100ms)
  /// - [timeout] - Optional timeout; throws [TimeoutException] if exceeded
  ///
  /// If no deserializer is provided:
  /// - If `T` is `String`, returns raw content
  /// - If `T` is `Map<String, dynamic>`, uses `jsonDecode(content)`
  static Future<T> Function() pollFile<T>({
    required String path,
    bool delete = false,
    T Function(String content)? deserializer,
    Duration pollInterval = const Duration(milliseconds: 100),
    Duration? timeout,
  }) {
    return () async {
      final stopwatch = timeout != null ? (Stopwatch()..start()) : null;

      while (true) {
        final file = File(path);
        if (await file.exists()) {
          final content = await file.readAsString();
          if (delete) {
            await file.delete();
          }

          if (deserializer != null) {
            return deserializer(content);
          }

          // Default handling for common types
          if (T == String) {
            return content as T;
          }
          if (T == dynamic || T.toString().contains('Map')) {
            return jsonDecode(content) as T;
          }
          return content as T;
        }

        if (stopwatch != null && timeout != null && stopwatch.elapsed > timeout) {
          throw TimeoutException('File $path did not appear within $timeout');
        }

        await Future.delayed(pollInterval);
      }
    };
  }

  /// Creates a wait function that polls until a condition returns non-null.
  ///
  /// Parameters:
  /// - [check] - Function that returns `null` to continue polling, or a value to complete
  /// - [pollInterval] - How often to check (default: 100ms)
  /// - [timeout] - Optional timeout
  static Future<T> Function() pollUntil<T>({
    required Future<T?> Function() check,
    Duration pollInterval = const Duration(milliseconds: 100),
    Duration? timeout,
  }) {
    return () async {
      final stopwatch = timeout != null ? (Stopwatch()..start()) : null;

      while (true) {
        final result = await check();
        if (result != null) {
          return result;
        }

        if (stopwatch != null && timeout != null && stopwatch.elapsed > timeout) {
          throw TimeoutException('Condition not met within $timeout');
        }

        await Future.delayed(pollInterval);
      }
    };
  }

  /// Creates a wait function that waits for multiple files to appear.
  ///
  /// All files must appear before returning. Returns contents in the same
  /// order as the input paths.
  ///
  /// Parameters:
  /// - [paths] - List of absolute paths to wait for
  /// - [delete] - Whether to delete files after reading (default: `false`)
  /// - [deserializer] - Optional function to parse each file's content
  /// - [pollInterval] - How often to check for files (default: 100ms)
  /// - [timeout] - Optional timeout for all files to appear
  static Future<List<T>> Function() pollFiles<T>({
    required List<String> paths,
    bool delete = false,
    T Function(String content)? deserializer,
    Duration pollInterval = const Duration(milliseconds: 100),
    Duration? timeout,
  }) {
    return () async {
      final stopwatch = timeout != null ? (Stopwatch()..start()) : null;
      final results = <String, T>{};

      while (results.length < paths.length) {
        for (final path in paths) {
          if (results.containsKey(path)) continue;

          final file = File(path);
          if (await file.exists()) {
            final content = await file.readAsString();
            if (delete) {
              await file.delete();
            }

            if (deserializer != null) {
              results[path] = deserializer(content);
            } else if (T == String) {
              results[path] = content as T;
            } else if (T == dynamic || T.toString().contains('Map')) {
              results[path] = jsonDecode(content) as T;
            } else {
              results[path] = content as T;
            }
          }
        }

        if (results.length < paths.length) {
          if (stopwatch != null && timeout != null && stopwatch.elapsed > timeout) {
            final missing = paths.where((p) => !results.containsKey(p)).toList();
            throw TimeoutException('Files did not appear within $timeout: $missing');
          }
          await Future.delayed(pollInterval);
        }
      }

      // Return in same order as input paths
      return paths.map((p) => results[p]!).toList();
    };
  }
}
